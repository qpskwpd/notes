### git基础操作

- `git clone + [仓库地址]` 命令即可，这是标准的克隆仓库命令。

- 执行 `git remote -v` 命令可以查看本地仓库所关联的远程仓库信息：

- Git 要求对本地仓库关联的每个远程主机都必须指定一个主机名（默认为 origin），用于本地仓库识别自己关联的主机，`git remote` 命令就用于管理本地仓库所关联的主机，一个本地仓库可以关联任意多个主机（即远程仓库）。

  ![此处输入图片的描述](img\git\clip_image001.png)

- 执行 `git status` 查看整个仓库的状态

- 使用 `git add [文件名]` 命令跟踪此新建文件，即把新增文件添加到暂存区，以备提交。

  如果对多个文件或目录进行了增删改，可以使用 `git add .` 命令全部添加到暂存区。

- 如果要撤销暂存区的修改怎么办？根据上图的提示，执行 `git reset -- [文件名]` 或者 `git rm --cached [文件名]` 命令即可。

  如果省略最后的文件名，把命令写成`git reset -- `即可把暂存区的全部修改撤销。

- `git diff`，它可以用来查看工作区被跟踪的文件的修改详情，只有在版本区中存在的文件才是被跟踪文件。

- `git log`，它用来查看版本区的提交历史记录

  - `git log [分支名]` 查看某分支的提交历史，不写分支名查看当前所在分支
  - `git log --oneline` 一行显示提交历史
  - `git log -n` 其中n是数字，查看最近n个提交
  - `git log --author [贡献者名字]`查看指定贡献者的提交记录
  - `git log --graph`图示法显示提交历史

  需要查看时间正序排列的信息，那么可以使用`git log --reverse`命令。

- 接下来需要对 Git 进行一些本地配置：
  - user.email：写入你自己注册 GitHub 账号的邮箱
  - user.name：你自己的 GitHub 账号名字

  这两个命令设置你的身份信息如下图。`git config -l`可以查看配置信息（就不展示截图了）：

  ![此处输入图片的描述](img\git\clip_image002.png)

  完成后，系统自动生成 Git 的配置文件，就是主目录中的隐藏文件 .gitconfig ：

  <img src="img\git\clip_image003.png" alt="此处输入图片的描述" style="zoom: 67%;" />

  上图所示的配置文件也是可以直接手动修改。

- 执行`git commit`命令生成一个新的提交，一个必须的选项`-m`用来提供该提交的备注：

  ![此处输入图片的描述](img\git\clip_image004.png)

- `git branch -avv`，它用来查看全部分支信息

- 将本地新增的提交推送到 GitHub 远程仓库中，命令是`git push`，后面不需要任何选项和参数，此命令会把本地仓库 master 分支上的新增提交推送到远程仓库的同名分支上

- 首先执行`git reset --soft HEAD^`撤销最近的一次提交，将修改还原到暂存区。`--soft` 表示软退回，对应的还有`--hard` 硬退回，后面会讲到，`HEAD^ `表示撤销一次提交，`HEAD^^` 表示撤销两次提交，撤销 n 次可以简写为`HEAD~n`。

- 再次修改 one.txt 文件，执行`git add .` 命令将新的修改添加到暂存区，然后执行 `git commit` 命令生成新的提交。

  可以看到本地仓库的 master 分支与远程仓库的 origin/master 分支在提交版本上有了冲突，又叫做提交时间线分叉。因为刚才的提交操作不是基于远程仓库 origin/master 分支的最新提交版本，而是撤回了一个版本。这种情况下也是可以将本地 master 分支推送到远程仓库的，需要加一个选项`-f` ，它是 `--force` 的简写，这就是强制推送

  ![此处输入图片的描述](img\git\clip_image005.png)

- `git reflog` 命令，它会记录本地仓库所有分支的每一次版本变化。实际上只要本地仓库不被删除，随你怎么折腾，都能回退到任何地方。reflog 记录只存在于本地仓库中，本地仓库删除后，记录消失。

  怎么回退到 5c04 那个版本呢？可以直接执行命令 `git reset --hard [版本号]` ，如果记不清版本号，也可以根据上图第 3 行的信息，执行 `git reset --hard HEAD@{2}` 命令，其中 HEAD@{2} 就是上图第 3 行第 2 列所示，这个命令的意思是回到当前分支最近两次提交版本变化前

- 重要的一点，本节全部命令中，只有 push 是需要联网执行的，它对远程仓库进行了修改。

### git分支操作

#### 一、添加 SSH 关联授权

上一节操作中每次提交都要手动输入用户名和密码，若想避免这些麻烦，可以在系统中创建 SSH 公私钥，并将公钥放到 GitHub 指定位置。如此操作即可生成 GitHub 账户对于当前系统中的 Git 授权。

终端执行 `ssh-keygen`命令按几次回车生成公私钥，公私钥存放在主目录下的隐藏目录 .ssh 中的两个文件中：

![此处输入图片的描述](img\git\clip_image011.png)

将 ~/.ssh/id_rsa.pub 文件中的公钥内容复制出来，实验环境中可以使用右侧工具栏中的剪切板复制：

![此处输入图片的描述](img\git\clip_image012.png)

然后在 GitHub 网页上添加公钥：

![此处输入图片的描述](img\git\clip_image014.png)

Title 自定义，把剪切板中的内容粘贴到 Key 中，点击绿色按钮添加 SSH Key 即可：

![此处输入图片的描述](G:\2019黑马Java(IDEA)\note\img\git\clip_image015.png)

回到仓库主目录，点击下图所示的绿色按钮，点击紫色框中的 “Use SSH”，然后复制这个链接。

![此处输入图片的描述](img\git\clip_image016.png)

在实验环境里删除原仓库，使用此链接重新克隆仓库。克隆仓库是需要确认连接，输入 yes 即可：

![此处输入图片的描述](img\git\clip_image017.jpg)

重要的一点：只有使用这种 git 开头的地址克隆仓库，SSH 关联才会起作用。

使用 SSH 的好处主要有两点：

- 免密码推送，执行 `git push` 时不再需要输入用户名和密码了；
- 提高数据传输速度。它不是必须的，比如在实验楼的课程中挑战环境是不可保存的，一次性的，这种环境就没有必要创建SSH了，因为相较好处来说，还是太麻烦了。

#### 二、为 Git 命令设置别名

上一节课程中的操作，有些命令的重复度极高，比如 `git status` 和 `git branch -avv` 等，Git 可以对这些命令设置别名，以便简化对它们的使用，设置别名的命令是 `git config --global alias.[别名] [原命令]`，如果原命令中有选项，需要加引号。别名是自定义的，可以随意命名，设置后，原命令和别名具有同等作用。操作如下：

![图片描述](img\git\clip_image018.png)

自己设置的别名要记住，也可以使用 `git config -l` 命令查看配置文件。下面文档中的命令将使用这些别名。

#### 三、Git 分支管理

下面介绍 Git 作为分布式版本控制器最强大的功能：分支管理。

##### 3.1 `git fetch` 刷新本地分支信息

在介绍分支前，先讲解另一个命令 `git fetch`，它的作用是将远程仓库的分支信息拉取到本地仓库，注意，仅仅是更新了本地的远程分支信息，也就是执行 `git branch -avv` 命令时，查看到的 remotes 开头的行的分支信息。

举例说明一下，首先我们在 GitHub 页面上对 one.txt 文件进行修改并增加一次提交。

提交完成后，提交数变成 3 个，点下图紫色框中的链接可以看到提交记录：

![此处输入图片的描述](img\git\clip_image019.png)

![此处输入图片的描述](img\git\clip_image0110.png)

在实验环境中执行 `git fetch` 命令，然后执行 `git branch -avv` 查看分支信息：

![此处输入图片的描述](img\git\clip_image0111.png)

 

![此处输入图片的描述](img\git\clip_image0112.png)

可以看到，本地分支 master 的版本号无变化，而远程分支已经更新。所以，fetch 命令的作用是刷新保存在本地仓库的远程分支信息，此命令需要联网。此时若想使本地 master 分支的提交版本为最新，可以执行 `git pull` 命令来拉取远程分支到本地，pull 是拉取远程仓库的数据到本地，需要联网，而由于前面执行过 `git fetch` 命令，所以也可以执行 `git rebase origin/master` 命令来实现 “使本地 master 分支基于远程仓库的 master 分支”，rebase 命令在后面还会经常用到，这里只需按部就班操作即可：

![此处输入图片的描述](img\git\clip_image0113.png)

 

![此处输入图片的描述](img\git\clip_image0114.png)

可以看到，远程仓库 master 分支、本地仓库的 origin/master 分支、本地仓库的 master 分支已经一致。

##### 3.2 创建新的本地分支

分支在项目开发中作用重大，多人协作时尤其不可或缺。例如一个项目上线了 1.0 版本，研发部门需要开发 1.1、1.2 两个测试版，增加不同的新功能，测试版的代码显然不能在正式版所在的分支上，此时需要新的分支来存放不同版次的代码。再例如实验楼的课程团队在维护课程仓库时，每个人都有各自的分支，在自己的分支上进行修改，然后向 master 分支提 PR（pull request），最后从 master 分支推送到线上。

首先，克隆远程仓库到本地，进入仓库主目录，执行 `git br` 查看分支信息：

![此处输入图片的描述](img\git\clip_image0115.png)

执行 `git branch [分支名]` 可以创建新的分支：

![此处输入图片的描述](img\git\clip_image0116.png)

 

![此处输入图片的描述](img\git\clip_image0117.png)

此命令创建新分支后并未切换到新分支，还是在 master 分支上，执行 `git checkout [分支名]` 切换分支，checkout 也是常用命令，先给它设置别名，然后切换分支：

![此处输入图片的描述](img\git\clip_image0118.png)

创建新分支还要手动切换太麻烦，介绍另一个常用的命令 `git checkout -b [分支名]` 创建分支并切换到新分支：

![此处输入图片的描述](img\git\clip_image0119.png)

 

![此处输入图片的描述](img\git\clip_image0120.png)

如上图所示的分支信息，前两行是新建的本地分支信息，它们的版本号与主分支 master 一致，这是因为在哪个分支上创建新分支，新分支的提交记录就与哪个分支一致。新建分支并无跟踪任何远程分支，所以没有 master 分支中的中括号和括号内的蓝色远程分支名。

假设我们要在当前分支 dev1 上开发一个新的功能，需要增加一个文件 new_func1，然后生成一个新的提交：

![此处输入图片的描述](img\git\clip_image0121.png)

 

![此处输入图片的描述](img\git\clip_image0122.png)

##### 3.3 将新分支中的提交推送至远程仓库

好，新功能已经写好并提交到了版本区，现在要推送了，推送到哪里呢？正常逻辑当然要推送到远程仓库的同名分支，不过现在远程仓库里只有一个分支：

![此处输入图片的描述](img\git\clip_image0123.jpg)

上图紫色框中是一个下拉按钮，点击后显示仓库中的全部分支，按钮上显示的是当前所在分支。

执行 `git push [主机名] [本地分支名]:[远程分支名]` 即可将本地分支推送到远程仓库的分支中，通常冒号前后的分支名是相同的，如果是相同的，可以省略 `:[远程分支名]`，如果远程分支不存在，会自动创建：

![此处输入图片的描述](img\git\clip_image0124.png)

上图命令可以简写为 `git push origin dev1` 。注意哦，这是我们创建 SSH 关联后第一次执行 push 命令，可以看到传输速度有明显的提高，更重要的是，不再需要重复输入用户名和密码了，另外打印信息的第一行是警告信息，因为是这个分支的第一次推送嘛，下次执行推送就不会再出现了。现在执行 `git br` 查看一下分支情况：

![此处输入图片的描述](img\git\clip_image0125.png)

可以看到，远程分支 origin/dev1 的信息已经在本地存在，且与本地同名分支一致。再看下 GitHub 页面的情况：

![此处输入图片的描述](img\git\clip_image0126.jpg)

很好，与预期毫无二致。

##### 3.4 本地分支跟踪远程分支

现在有个问题，当我们再次在 dev1 分支上修改并提交，推送到远程仓库时还是要输入上面的那个长长的命令，好不方便。如果能和 master 分支一样跟踪远程同名分支，就可以直接使用 `git push` 命令推送了。有办法的，执行这个命令 `git branch -u [主机名/远程分支名] [本地分支名]` 将本地分支与远程分支关联，或者说使本地分支跟踪远程分支。如果是设置当前所在分支跟踪远程分支，最后一个参数本地分支名可以省略不写：

![此处输入图片的描述](img\git\clip_image0127.png)

 

![此处输入图片的描述](img\git\clip_image0128.png)

这个命令的 `-u` 选项是 `--set-upstream` 的缩写。可不可以让本地分支跟踪远程非同名分支呢？可以的，尽管几乎遇不到这种自找麻烦的需求。可不可以撤销本地分支对远程分支的跟踪呢？也是可以的，执行 `git branch --unset-upstream [分支名]` 即可撤销该分支对远程分支的跟踪，同样地，如果撤销当前所在的分支的跟踪，分支名可以省略不写：

![此处输入图片的描述](img\git\clip_image0129.png)

 

![此处输入图片的描述](img\git\clip_image0130.png)

问题又来了，前面的操作是先将本地分支推送到远程仓库，使远程仓库创建新分支，然后再执行命令使本地分支跟踪远程分支，有没有办法在推送时就自动跟踪远程分支呢？有的，在推送的时候，加个 `--set-upstream` 或其简写`-u`选项即可，现在切换到 dev 分支试一下这个命令：

![此处输入图片的描述](img\git\clip_image0131.png)

 

![此处输入图片的描述](img\git\clip_image0132.png)



##### 3.5 删除远程分支

接下来，介绍一下删除分支的方法。

首先，删除远程分支，使用 `git push [主机名] :[远程分支名]` ，如果一次性删除多个，可以这样：`git push [主机名] :[远程分支名] :[远程分支名] :[远程分支名]` 。此命令的原理是将空分支推送到远程分支，结果自然就是远程分支被删除。另一个删除远程分支的命令：`git push [主机名] --delete [远程分支名]`。删除远程分支的命令可以在任意本地分支中执行。两个命令分别试一下：

![此处输入图片的描述](img\git\clip_image0133.png)

 

![此处输入图片的描述](img\git\clip_image0134.png)

可以看到本地仓库已经没有远程分支 dev 和 dev1 的分支信息。查看 GitHub 仓库页面：

![此处输入图片的描述](img\git\clip_image0135.png)

也只剩 master 一个分支。操作成功。

 

##### 3.6 本地分支的更名与删除

回到实验环境，使用 `git branch -D [分支名]` 删除本地分支，同样地，此命令也可以一次删除多个，将需要删除的分支名罗列在命令后面即可。在此之前，先介绍一个极少用到的命令：给本地分支改名 `git branch -m [原分支名] [新分支名]` ，若修改当前所在分支的名字，原分支名可以省略不写：

![此处输入图片的描述](img\git\clip_image0136.png)

好，现在要一次性删除本地分支 ved 和 dev1。需要注意的一点：当前所在的分支不能被删除。切换到 master 分支，然后执行 `git branch -D ved dev1` 命令：

![此处输入图片的描述](img\git\clip_image0137.png)

执行 `git branch -avv` 查看当前仓库分支状态：

![此处输入图片的描述](img\git\clip_image0138.png)

很好，一切都回到了课程开始时的样子，就像什么都没有发生。本节课程就到这里。