#### Java基础

##### Java简要介绍

Java是一种以面向对象为主要特性的语言，它通过字节码和虚拟机的形式实现跨平台。面向对象的主要特性是封装、继承、多态。

##### ArrayList Vector Array CopyOnWriteArrayList异同

- 它们都是单列容器，底层都使用数组实现。
- ArrayList是非同步的，Vector是同步的，CopyOnWriteArrayList可以做到只有写入与写入需要同步，写入时不影响读取操作，这是因为它的所有可变操作（add，set等等）都是通过创建底层数组的新副本来实现的，即底层数组不会被修改，只会被替换。
- Array通过反射提供动态创建和访问数组的功能。

##### hashmap hashtable concurrenthashmap异同

- 它们都是双列容器，hashtable concurrenthashmap都是懒加载（put的时候创建数组）。

- hashmap底层为数组+链表/红黑树，可以存储null键和null值，非同步。

  - 为什么用红黑树不用AVL树，因为红黑树插入和删除节点后的调整比AVL树更快，而查询性能损失并不多。

  - ```
    (h = key.hashCode()) ^ (h >>> 16)
    ```

    hash函数：为什么高16位和低16位异或，因为高低位都参与到计算中，尽可能降低hash冲突。

  - ```
    (n - 1) & hash
    ```

    为什么HashMap的数组长度要取2的整数幂，因为这样（数组长度-1）正好相当于一个“低位掩码”，与key的hash做与运算，得到数组下标。本质上是因为除数为2的幂次时，取余操作等价于被除数和（除数-1）的与操作。

  - 扩容时不重新计算hash，某些元素直接使用原索引+旧数组容量作为新的位置。

    ```
    因为扩容时直接乘以2，数组长度始终保持为2的幂，它的二进制码只有一个1。
    通过if ((e.hash & oldCap) == 0)选出保持在原来位置以及要放入新位置的元素。
    ```

  - 链表转红黑树的阈值为什么是8，因为与泊松分布有关，hash函数选择比较好的时候，链表的长度到达8给可能性很小。但不能避免用户选择不好的hash函数。

  - JDK8中做的优化：

    - 链表长度大于8且数组长度大于64时，链表会转换为红黑树。

    - 插入时在链表尾部插入，为了避免多线程环境下rehash形成环（当然多线程环境下还是不安全的）。

      <img src="img/rehash成环.png" style="zoom: 15%;" />

    - entry被node替代，因为加入了树节点。

    - 先插入再扩容，而且扩容时不需要重新计算hash。

- hashtable底层为数组+链表，不可以存储null键和null值，同步。

- concurrenthashmap底层分情况，不可以存储null键和null值，线程安全，所有变量使用volatile修饰。

  - JDK1.7为分段的数组+链表，通过给每个段进行加锁ReentrantLock，实现线程安全。
  - JDK1.8为数组+链表/红黑树，并发控制使用synchronized和CAS来操作。
    - synchronized：将数组节点作为锁，更新值或尾部插入节点。
    - CAS：数组的空位置插入节点。
  - 1.8的锁粒度更小，并且使用内置锁替代重入锁。使用红黑树进行优化。

##### hashmap linkedhashmap treemap异同

- hashmap基于数组+链表/红黑树实现，linkedhashmap基于hashmap和双向链表实现（继承hashmap，node添加before和after两个指针），treemap基于红黑树实现。

  <img src="img/LinkedHashMap.png" style="zoom: 67%;" />

- hashmap不能保证数据有序，linkedhashmap记录了数据的插入顺序（迭代器根据双向链表遍历，因此有序），treemap能够把它保存的记录根据键排序。

##### 重写equals方法的时候需要重写hashCode方法

因为equals方法默认比较两个对象的地址，重写equals方法后，为了让逻辑上相等的对象返回相同的hashcode，需要重写hashcode方法，否则hashmap这些用到hashcode的类会认为两个逻辑上相等的对象不相等。

如果两个对象相等（equal），它们的hashcode一定相同；

如果两个对象有相同的hashcode，它们不一定相等（equal）。

##### string为什么定义成final

- string应用太广，为了安全性考虑，因为不可变的对象天生线程安全，另外类加载机制使用字符串定位class文件。不可被继承也就不会出现破坏语义的子类。
- 其次可以用于实现字符串常量池，节省内存空间，提高效率。
- 怎么做到不可变的：class定义为final，byte数组定义为private final，绝大部分方法都是返回新的string。

##### instanceof的作用与原理

- `A instanceof B` 判断object A是否为class B的实例或其子类实例（B也可以为接口）。
- 原理：判断B是否在A的所有父类、实现的接口组成的集合里。

##### 如何获取无符号类型

```
System.out.println((Integer.MAX_VALUE<<1) & 0xFFFFFFFFL);
```

##### 抽象类和接口

- 抽象类主要用于捕捉子类的通用特性，是对类的抽象。
- 接口是抽象方法/功能的集合，是对行为的抽象。
- 相同之处：
  - 它们都不能被实例化、位于继承的顶端。
  - 都具有抽象方法。
- 不同之处：
  - 关键字不同。
  - 抽象类可以有构造函数，接口不能。
  - 一个类只能继承一个抽象类，但可以实现多个接口。

##### 封装

- 把一些属性和方法封装到一个类里，并且提供修饰符来控制访问权限。
- 好处是提高代码的复用性、隐藏细节（private修饰符）、方便扩展与维护（数据与操作不分离）。

##### 继承

- 子类继承父类的属性和方法，但子类可以拥有自己的属性和方法，也可以重写父类的方法。
- 好处是提高代码的复用性和扩展性。

##### 多态

- 多态是指引用变量所指向的具体类型以及调用的方法是在运行期间才能确定的，具体体现在使用父类或接口的引用变量指向子类或实现类的实例对象。
- 可以分为编译时多态（方法重载，通过静态分派实现）和运行时多态（方法重写，通过动态分派实现）。
  - 重载：同一个类中，相同的名字，不同的参数列表。
  - 重写：子类对父类的方法进行重新实现。
- 好处是降低耦合，提高扩展性（方法的接收参数不用随着子类的增多而产生变化）。

##### 反射

- 运行过程中动态获取类的信息，或者动态调用对象的方法。
- 应用场景：运行过程中动态加载字节码文件，动态代理。
- 原理：通过获取类加载后在堆中生成的class对象，获取该类的信息。
- 获取反射的三种方法：
  - Class.forName(全限定名)。
  - 类名.class。
  - 对象的getClass()方法。

##### 泛型

- 将操作的**数据类型**指定为方法签名中的一种**特殊参数**，这种参数类型用在类、接口和方法的创建中，分别构成泛型类、泛型接口和泛型方法。

- Java的泛型实现方式为“类型擦除式泛型”，它只在程序源码中存在，编译成字节码后，全部泛型类型都被替换为原来的裸类型，并在相应位置插入了强制转型代码。

##### I/O流

- 按流的流向，划分为输入流和输出流。

- 按操作单元，划分为字节流和字符流。

- 按流的角色，划分为节点流（file、pipe、array这种节点）和处理流（buffer这种缓冲区）。

  <img src="D:\Notes\img\IO流分类.png" style="zoom: 67%;" />

##### 创建对象的四种方式

- 通过new关键字，调用实例构造器。
- 通过反射，如当前类对象的newInstance()方法。
- 通过反序列化。
- 通过深拷贝，调用重写的clone方法。

##### 深拷贝与浅拷贝

- 深拷贝是复制一个对象之后，引用类型引用的对象，复制独立的一份。
- 浅拷贝是复制一个对象之后，引用类型只复制引用，不复制引用的对象。

- Cloneable接口中的clone方法是浅拷贝。
- 如何实现深拷贝：
  - 继承Cloneable接口，重写clone方法。
  - 利用序列化。

##### 序列化与反序列化

- 序列化是将**对象**转换为字节流，而反序列化则是把对象从字节流中读取出来。
- 作用为完整地保存和传递对象。
- 如何实现：实现Serializable接口，通过ObjectInputStream和ObjectOutputStream中的方法进行序列化和反序列化。
- 序列号作为类的版本信息，在反序列化过程中用于告知接收者应该使用与序列号相同的类。
- static和transient类型的成员数据不能被序列化。因为static代表类的状态，transient代表对象的临时数据。
- 序列化的方式：XML、JSON、YAML、Java自带的序列化。

##### BIO、NIO、AIO

- BIO：同步阻塞式IO。线程进行IO操作时需要被挂起，等待IO操作完成。以这种模式进行通信的服务器，对于每条连接都创建一条线程去处理，因此并发访问量增加后，线程数目膨胀，造成服务器宕机。适用于连接数目比较少的场景。

  采用线程池可以避免线程数目膨胀，达到伪异步IO的效果，但是本质上仍然是同步阻塞IO，因此无法达成高的并发量。

- NIO：同步非阻塞式IO。线程进行IO操作时不需要被挂起，但通过轮询方式检查IO操作是否就绪。Java NIO通过一个多路复用器Selector轮循多个通道Channel，某个Channel的IO就绪时就会被选择出来进行后续的IO操作。适用于连接数目多且连接比较短的场景，如聊天服务器。

- AIO：异步IO。线程进行IO操作时不需要等待和轮询，IO操作完成时由内核通知。通过事件和回调机制实现。适用于连接数目多且连接比较长的场景。AIO目前在Linux下还没有完全实现，而且需要考虑适用场景，因此并不是无脑选择AIO。

#### Java线程与同步相关

##### 锁：互斥（阻塞）同步

- volatile：轻量级的同步机制，仅仅⽤来保证该变量对所有线程的并发可⻅性，但不保证原⼦性。可以用于禁止指令的重排序。

  因为会在赋值后多执行一条带有Lock前缀的空操作（内存屏障，意味着之前所有的操作已经执行完成），它会将当前处理器缓存行的数据写回到内存，同时使其他处理器里缓存了该内存地址的数据无效。这样就会使该数据对其他线程立即可见。

  但是写操作并不是原子性的，通常有好几条字节码指令，因此不能保证多个线程同时修改数据时的一致性。可以与原子类的CAS操作结合，实现原子性。

  volatile变量通常用作状态标志。

- synchronized：语言内置的互斥锁，保证可见性与原子性。

  同步代码块在字节码层面由monitorenter和monitorexit完成，标记为synchronized的方法会在方法表中ACC_SYNCHRONIZED字段体现，底层使用ObjectMonitor作为锁对象，它保存一些信息，如被哪条线程持有，重入次数等。

  JDK6之后有一些升级，如偏向锁、轻量级锁、锁粗化、锁消除、自适应自旋等。

- Lock：显式互斥锁，底层通过AQS实现。主要有ReentrantLock和ReentrantReadWriteLock。

  相比synchronized，用法更加灵活，但需要手动释放锁。提供了一些更高级的功能，比如

  - 等待的线程超过时间后放弃等待。
  - 公平锁，先到先服务（使用队列完成）。
  - 支持条件对象。

  基本上是根据互斥量（AQS的state变量）来实现的，即0表示锁空闲，其他值表示锁被占用。

  读写锁可以做到读数据时允许多个线程同时进入临界区，而写数据时，所有线程都是互斥的。

##### AQS

- AbstractQueuedSynchronizer：Lock的底层实现，为实现阻塞锁和相关同步器（信号量、事件等）提供一个框架。
- AQS维护了一个volatile语义(支持多线程下的可见性)的共享资源变量state和一个FIFO**线程**等待队列(线程竞争state被阻塞时会进入此队列)。
- 拥有两种线程模式：
  - 独占模式（互斥量）：只有单个线程能够成功获取资源并执行，如ReentrantLock。
  - 共享模式（信号量）：多个线程可成功获取资源并执行，如Semaphore/CountDownLatch等。
- 通过state变量实现可重入的机制。

##### 死锁

资源死锁通常是一个线程需要持有两个锁才能继续执行，但它和另一个线程互相占有一个对方持有的锁，等待对方释放。主要原因是循环依赖，两个线程获取锁的顺序交错/不确定。解决方法有：

- 固定加锁的顺序。
- 开放调用，调用某个方法时不需要持有锁，而是只保护涉及操作共享变量的代码块。
- 使用具有定时功能的显式锁。

##### 原子类：非阻塞同步

- CAS：更新一个变量时，首先将拿到的内存值与期望值比较，如果相同，则将它更新为新值。如果不相同，则将期望值更新为内存值，**并自旋不停地尝试**。**它的关键其实在于CAS是CPU指令级别的原子操作，因此必然会保证一个线程执行完毕的结果先写入内存，让其他线程可见，这样与期望值的比较就能发挥作用。**
- 原子变量类包括基本数据类型、数组、引用类型、对象的属性等。带有版本信息的原子类，可以解决ABA问题。

##### ThreadLocal

ThreadLocal提供线程私有的变量，可以用于一些线程之间需要隔离的操作，如对于数据库的连接需要每个线程独占。

提供一个set方法，使用map集合将ThreadLocal对象和变量关联起来。**每个Thread对象持有一个ThreadLocalMap对象**，调用get方法时，当前线程的ThreadLocal对象作为key获取它对应的值。

ThreadLocalMap的entry使用弱引用，为了使threadlocal对象能被GC回收，但是不调用remove的话，entry的value可能存在内存泄漏。

<img src="img/threadlocal引用关系.png" style="zoom: 67%;" />

##### Java线程

- 使用操作系统的原生线程1对1映射。

- 使用抢占式线程调度，有10个线程优先级。

- 定义了6种线程状态：新建（还没有调用start方法）、运行、阻塞、限时等待、无限期等待（类似于就绪）、结束。

  <img src="img\java虚拟机\线程状态转换.jpg" style="zoom: 33%;" />

- 创建线程的方式：继承Thread类、实现Runnable接口、实现Callable接口、线程池。

##### Java线程池

线程的集合，当请求到来时给它分配一个空闲线程，任务完成后回到线程池中而不是销毁。

为什么用它，因为为每个请求开启一个线程，一方面线程的创建和销毁开销比较大，另一方面请求过多或收到恶意攻击将导致程序崩溃。因此使用线程池可以减少对线程生命周期的管理，提高性能。另外，使用线程池还可以根据项目灵活地控制并发的数目。

- 线程池API：

  ThreadPoolExecutor类最为常用，一般使用Executors工厂方法来配置。它的函数签名为

  ```java
  public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,//线程数超过核心线程数时，闲置的线程等待的最大时间
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
  ```

  - 如果运行的线程数小于corePoolSize，则新创建线程来处理请求，即使其他线程是空闲的。
  - 如果运行的线程数大于corePoolSize，小于maximumPoolSize，则仅当任务队列满时才创建新线程。
  - 如果设置corePoolSize和maximumPoolSize相同， 则创建了固定大小的线程池。
  - 如果设置maximumPoolSize为一个巨大的值如Integer.MAX_VALUE，则允许线程池适应任意大小的并发任务。

  任务队列有三种排队策略：

  - 直接提交给线程（同步移交，如**SynchronousQueue**）。
  - 无界限的队列（超过核心线程数就放入队列等待，如**LinkedBlockingQueue**）
  - 有界限的队列（需要权衡队列容量与最大线程容量，如**ArrayBlockingQueue**）。

  拒绝任务有四种策略：

  - 直接抛出异常（AbortPolicy）。
  - 用调用者所在线程来执行任务（CallerRunsPolicy）。
  - 直接丢弃该任务（DiscardPolicy）。
  - 丢弃最老的一个任务（DiscardOldestPolicy）。

  默认实现的池：

  - newFixedThreadPool，一个固定线程数的线程池。

    ```java
    public static ExecutorService newFixedThreadPool(int nThreads) {
    	return new ThreadPoolExecutor(nThreads, nThreads,
                                        0L, TimeUnit.MILLISECONDS,
                                        new LinkedBlockingQueue<Runnable>());
    }
    ```

  - newCachedThreadPool，直接提交给线程的、最大线程数为Integer.MAX_VALUE的线程池。

    ```java
    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                        60L, TimeUnit.SECONDS,
                                        new SynchronousQueue<Runnable>());
    }
    ```

  - newSingleThreadExecutor，单个工作线程的线程池。

    ```java
    public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
            	(new ThreadPoolExecutor(1, 1,
                                        0L, TimeUnit.MILLISECONDS,
                                        new LinkedBlockingQueue<Runnable>()));
    }
    ```

- 线程池执行流程：当然取决于具体的线程池实现，通常情况下是

  <img src="img/线程池执行流程.png" style="zoom:200%;" />

- 阻塞队列：当队列满时，队列会阻塞插入元素的线程，直到队列不满。队列为空时，获取元素的线程会等待队列变为非空。

  为什么用阻塞队列不用非阻塞队列：使用非阻塞队列，当队列满的时候，新的任务将无法得到保留。

##### wait()和sleep()的区别

- wait来自Object类，sleep来自Thread类。
- wait只能在同步代码块/同步方法中使用，sleep可以在任意处使用。
- wait会释放执行权和锁，sleep会释放执行权但不释放锁。
- wait不指定时间需要notify或notifyAll唤醒，sleep到时间就会自动唤醒。

- wait的底层实现：JVM层面通过ObjectMonitor对象的wait()方法实现，linux层面通过系统调用pthread_cond_wait()阻塞在条件变量上。

#### Java虚拟机

##### 运行时数据区

方法区、堆，线程共享，栈（虚拟机栈，本地方法栈）、程序计数器，线程私有。

- 方法区用于存放加载的类型信息、常量、静态变量等。

- 堆用于存放对象。
- 栈用于存放局部变量、操作数栈、方法出口等。
- 程序计数器用于指示当前线程执行的字节码指令行号。

##### new指令创建对象过程

1. 首先检查类型是否已被加载、解析和初始化过。
2. 类型检查通过后，为对象分配一块内存空间。
3. 将内存空间初始化为0，对对象头（类的信息、哈希码、GC年龄等）进行设置。
4. 执行实例构造函数，对对象进行初始化。

- 对象的内存布局：对象头、实例数据和对齐填充。

  对象的访问方式有句柄和直接指针两种，Java为直接指针。

##### 垃圾收集

  - 如何判断对象存活：引用计数法、可达性分析。
  - 垃圾收集算法：标记-清除，标记-复制，标记-整理。
  - 经典垃圾收集器：基于分代收集理论，通常为两类，一类用于收集新生代，一类用于收集老年代。

    - Serial：新生代收集器，基于标记-复制算法。单线程工作。
    - ParNew：新生代收集器，基于标记-复制算法。多线程工作。
    - Parallel Scavenge：新生代收集器，基于标记-复制算法。多线程工作。可以控制吞吐量。
    - Serial Old：老年代收集器，基于标记-整理算法。单线程工作。
    - Parallel Scavenge Old：老年代收集器，基于标记-整理算法。多线程工作。可以控制吞吐量。
    - CMS：老年代收集器，基于标记-清除算法。多线程工作。可以并发标记和清除，低停顿。
    - Garbage First：混合收集器，基于标记-复制算法。基于Region的堆内存设计，根据Region的价值进行回收，停顿时间可控。
      - CMS和Garbage First的标记：初始标记，标记GC Roots直接关联到的对象；并发标记，对堆中的对象进行可达性分析，标记出存活的对象；最终标记，修正变更的标记。
  - 过程：当一个对象已经不存在指向它的引用时，它成为可回收的对象。虚拟机会额外启动一条垃圾收集线程对这些可回收对象进行回收，总体过程就是**先通过可达性分析进行标记，然后回收**。
  - 时机：
      - Minor-GC：Eden空间不足时。
      - Full-GC：老年代空间不足时，或者调用System.gc()。
  - 有垃圾收集为什么还会产生内存泄漏：
    - IO连接、数据库连接、网络连接等不显式关闭则会造成内存泄漏。
    - 静态集合类、匿名内部类、threadlocal等也可能造成内存泄漏。

##### class文件

采用无符号数和表两种数据类型存储数据。结构为魔数、虚拟机版本、常量池表、访问标志、继承关系、字段表、方法表、属性表。

##### 类加载机制

虚拟机把描述类的class文件加载到内存，对数据进行校验、解析和初始化的过程。

类加载的过程为**加载**、连接（**验证、准备、解析**）、**初始化**、使用和卸载。

- 加载：通过类的全限定名获取class文件，将它转化为方法区的运行时数据结构，在堆中生成一个对应的Class对象。
- 验证：class文件格式校验、类的元数据验证、方法体的字节码验证、符号引用验证。
- 准备：为类中定义的静态变量分配内存并设置初始值，初始化虚方法表。
- 解析：将常量池内的符号引用替换为直接引用。
- 初始化：执行类构造器方法，根据代码的内容初始化静态变量。

##### 类加载器

在虚拟机外部实现，通过一个类的全限定名获取它的class文件。不同的类加载器加载的同一个class文件也不是一个类。

- 类加载架构：三层类加载器，双亲委派模型。

  启动类加载器，扩展类加载器（平台类加载器，JDK9），应用程序类加载器。它们管理的范围不同，确保程序运行的稳定性，如java.lang.Object类只会由启动类加载器加载，所有的java.lang.Object类都是同一个。

  工作机制：一个类加载器收到的类加载请求后，首先把它委派给父类加载器去完成，每一层都是如此。只有当父类加载器无法完成加载请求时，子类加载器才会尝试完成。


##### 方法调用

解析调用和分派调用两种。

  - 解析调用：静态方法、私有方法、实例构造器等非虚方法，在类加载的解析阶段就能确定方法的版本。
  - 分派调用：静态分派（重载，编译时根据传递的参数确定方法版本）、动态分派（重写，运行时根据实际对象确定方法版本）。

##### Java内存模型

- Java内存模型将内存分为了**主内存和工作内存**。所有的变量都存储在主内存中，每条线程拥有自己的工作内存，其中保存被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存完成。
- 定义了几个原子操作，用于完成主内存与工作内存之间的交互。
- 定义了volatile变量的使用规则。
- 先行发生原则。

#### 操作系统

##### 进程的创建过程

1. 将代码和静态数据（例如初始化变量）加载到内存。
2. 创建和初始化栈和堆。
3. 进行I/O设置，如默认打开3个文件，用于标准输入、输出和错误。
4. 找到程序的入口函数。

##### 进程、线程之间的区别与通信方式

- 进程是一个正在运行的程序的实例，它是系统分配资源的独立单位。它包含程序运行的所有资源，如程序正文、打开的文件、程序计数器等。

  线程是进程的执行单元，每个进程至少有一条线程，它是CPU调度的的基本单位。它包含程序计数器、寄存器、堆栈等。

- 进程之间的通信方式有（用于进程之间的数据交互或同步）
  - 管道（pipeline）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。
  - 信号量：用一个整型变量记录可以进入临界区的最大进程数。
  - 信号：用于通知接收进程某个事件已经发生，如`kill -9`。
  - 消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。
  - 共享内存。
  - 套接字（socket）：通常用于不同机器的进程之间通信，如互联网。
- 线程之间的通信方式有（与进程类似）
  - 锁机制：各种互斥锁、条件变量。
  - 信号量：用一个整型变量记录可以进入临界区的最大线程数。两种原子操作down和up，类似于sleep和wakeup。当一个线程进入临界区时，使用down检查信号量是否大于0，若大于0，则将其值减1，若为0，则线程将睡眠。当一个线程离开临界区时，使用up将信号量的值加1，如果该信号量有睡眠线程，则值仍然为0，但唤醒该线程。
  - 信号：类似Java中的wait/notify方法。
  - 消息队列。
  - 共享变量。

##### 同步IO/异步IO

同步IO中，用户进程发起IO操作后需要等待（阻塞）或轮询（非阻塞）IO操作是否就绪，然后将数据从内核态拷贝到用户态，这个过程也需要阻塞。

异步IO中，用户进程发起IO操作后返回，继续运行。IO操作完成时得到通知，数据从内核态拷贝到用户态的过程由内核完成，因此全程不需要阻塞。

<img src="img/IO.png" style="zoom: 67%;" />

- 同步IO的特点：
  - 同步IO指的是用户进程触发I/O操作并等待或者轮询的去查看I/O操作是否就绪。
  - 同步IO的执行者是IO操作的发起者。
  - 同步IO需要发起者进行内核态到用户态的数据拷贝过程，所以这里必须阻塞。

- 异步IO的特点：
  - 异步IO是指用户进程触发I/O操作以后就立即返回，继续开始做自己的事情，而当I/O操作已经完成的时候会得到I/O完成的通知。
  - 异步IO的执行者是内核线程，内核线程将数据从内核态拷贝到用户态，所以这里没有阻塞。

##### 任务调度算法

- 轮转调度：每个进程被分配一个时间段，允许进程在该时间段内运行。

  缺点是时间片的长度设置，设置过短导致进程切换频繁，很多时间浪费在管理进程上，设置过长导致后面的进程等待时间过长，响应太慢。

- 优先级调度/多级反馈队列：每个队列被赋予一个优先级，允许高优先级队列中的可运行进程先运行。在每一个优先级队列里可以使用轮转调度。

  规则1：如果A的优先级 > B的优先级，运行A（不运行B）。
  规则2：如果A的优先级 = B的优先级，轮转运行A和B。
  规则3：工作进入系统时，放在最高优先级（最上层队列）。
  规则4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级（移入低一级队列）。
  规则5：经过一段时间S，就将系统中所有工作重新加入最高优先级队列。
  
- 当然还有先到先服务、非抢占式短作业优先、抢占式短作业优先等等。

- 多处理器调度算法有：O(1)调度程序、完全公平调度程序（CFS）以及BF调度程序（BFS，brain fuck scheduler，脑残调度器）。

##### 虚拟内存

- 通过分页交换技术实现，将虚拟地址空间分解成页，将每一页或者映射到物理内存的某个页框，或者解除映射。

- 页面置换算法：
  - OPT，最优页面置换算法：标记一个页面下次被使用时需要经过多少条指令，然后置换出标记最大的页面。但是不可实现。
  - FIFO，先进先出页面置换算法：队列头最先进来的页面将被置换出去。
  - LRU，最近最少使用页面置换算法：每当新加入一个页面，或一个页面被使用，将它放入链表头，链表满的时候置换出链表尾的页面。
  
- 虚拟地址到物理地址的映射（MMU的原理）：虚拟地址被分为虚拟页号（高位）和偏移量（低位）两部分。选择不同的位数可以决定页面的数量和每页的大小。例如16位地址，高4位作为页号，低12位作为偏移量，即分成16个页面，每个页面4096字节。

  页号可以作为页表的索引，以找到该页面对应的页框号。将页框号与偏移量拼接，则为实际的物理地址。

  <img src="img/ModernOS/3-10.png" style="zoom: 50%;" />

##### 上下文切换

上下文切换是指CPU的控制权由运行任务转移到另外一个就绪任务。

- 让步式上下文切换。执行线程主动释放CPU，与锁竞争严重程度成正比，可通过减少锁竞争来避免。
- 抢占式上下文切换。线程因分配的时间片用尽而被迫放弃CPU或者被其他优先级更高的线程所抢占，一般由于线程数大于CPU可用核心数引起，可通过调整线程数，适当减少线程数来避免。

##### Linux

- 常用指令
  - CPU使用率

    通过top、ps、pidstat等工具，可以找到具体的进程。perf可以分析具体的事件。

  - 查看进程IO占用

    iotop、pidstat

  - 查看本机各端口的网络连接情况

    netstat

  - 根据关键字查看日志中关键字的上下10行：`grep -C 10 "SGD" 0.py`。

- 启动过程
  1. 加载BIOS硬件信息。
  2. 读取引导文件，引导内核。
  3. 运行init进程，设定运行级别（如单用户模式/多用户模式，有无网络支持等等）。
  4. 建立终端，用户登录。
  
- 重定向和管道是怎么实现的？

  通过fork和exec的分离，即创建子进程后并不马上执行另一个程序，等实际调用exec时再进行，这中间可以用于完成其他功能。

#### 计算机网络

##### MAC地址

- 长48位，由厂商识别码和厂商内识别码来保证不重复。

  <img src="img/TCPIP/15.png" style="zoom:50%;" />

##### 端口

- 端口号用于识别同一台计算机中进行通信的不同应用程序，也被称为程序地址。

##### NAT

- NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时使用全局IP的技术。当私有网络内的多台机器同时与外部进行通信时，将端口号一起转换（NAPT）。

##### 五层/七层网络体系

- 应用层：HTTP、SMTP、FTP、DNS、SSH、DHCP

  - 作用：负责具体应用的传输规则。

- 传输层：TCP、UDP

  - 作用：负责在两个进程之间建立逻辑信道，提供通用的数据传输。

- 网络层：IP、ARP、ICMP、各种路由协议（RIP、OSPF、BGP）

  - 作用：负责在整个网络中通过路由将数据包传输到对方主机。

- 数据链路层：以太网、PPP、各种WLAN协议（IEEE802.11、蓝牙）

  - 作用：负责在局域网中传递数据包。

- 物理层

  与OSI七层网络体系的区别在于表示层和会话层被取消，作用融入到应用层中。

##### TCP/UDP

- UDP（user data protocol）提供面向无连接的通信，可以随时发送数据，不需要接收端进行确认。

  不提供流量控制、丢包重发等等复杂的控制功能，因此不能保证可靠传输。

  不提供拥塞控制，网络出现拥塞后不会使发送端降低速率。

  面向报文，一次传输交付一个完整报文，因此传输时不合并、拆分，不存在粘包问题。

  支持一对一、一对多、多对一和多对多的通信。

- TCP（transmission control protocol）提供面向有连接的通信，而且是全双工通信。

  提供了数据传输时充分的控制功能（确认应答、重发控制、流量控制、拥塞控制等），以实现可靠性传输。

  面向字节流，传输时拆分为数据段，因此可能出现粘包问题。

  提供一对一的通信。

- 三次握手：假设B处于监听状态，A首先向B发送一个请求报文，SYN=1。然后B向A发送一个回复报文，SYN=1，ACK=1。最后A再进行确认，向B发送一个回复报文，ACK=1。这个过程种虽然没有实际数据，但需要双方确定序列号。

  为什么三次：一个角度是避免失效的连接请求发送到服务端，服务端直接建立连接浪费资源。另一个角度是确认双方的收发功能都没有问题。

- 四次挥手：A要断开连接，向B发送一个请求报文，FIN=1。然后B向A发送一个回复报文，ACK=1，表明B知道要断开连接了，此时处于半断开状态（A已经不会再给B发送数据）。然后B可能还有数据要发送，因此等剩余数据发送完毕后，向A发送一个回复报文，FIN=1。然后A再进行确认，向B发送一个回复报文，ACK=1，接着等待一段时间（TIME_WAIT状态，2MSL），确保最后这个报文到达了B，以及本次连接产生的所有报文都从网络中消失。

- TCP的状态：

  ![](img/TCP11种状态.png)

- 重发控制（ARQ，automatic repeat request，停止等待协议）：发送端发包后计算往返时间，将往返时间和偏差相加作为重发时间间隔。再次发送时，以2、4的指数增长。

  <img src="img/TCPIP/57.png" style="zoom:33%;" />

- 滑动窗口/流量控制（连续ARQ）：发送端控制一个滑动窗口，滑动窗口内的数据不需要进行确认即可直接发送，接收端通常采用累积确认的方式，对按序到达的最后一个包进行确认，发送端收到这个确认后将滑动窗口向后推进。滑动窗口大小由接收端的缓存大小所确认的，以确保接收端来得及接收数据。

- 拥塞控制（慢启动、拥塞避免、快重传、快恢复）：发送端控制一个拥塞窗口，通信开始时为了避免发送一个大数据导致网络瘫痪，使用慢启动算法，即拥塞窗口设置为一个报文段，每收到一个ACK，拥塞窗口增加一个报文段。当拥塞窗口超过慢启动阈值后，拥塞窗口呈线性增长，即拥塞避免算法。

  当出现超时重发时，慢启动阈值设置为当前窗口的一半，并将拥塞窗口回归1个报文段。

  当出现重复确认应答时，即快重传算法，慢启动阈值设置为当前窗口的一半，并将拥塞窗口设置为慢启动阈值，即快恢复算法。

  ![](img/TCPIP/65.png)

- 提高网络利用率的规范

  - Nagle算法：仅当满足已发送的数据都已经收到ACK，或可以发送MSS长度的数据时进行发送数据，否则就延迟发送数据。
  - 延迟确认应答：接收端收到数据后不马上发送ACK，避免每次接收到数据后由于缓冲区的占用发送小的窗口大小。
  - 捎带应答：确认应答和回执数据通过一个包发送。例如三次握手中服务器给客户都发送ACK和SYN在一个包中。

- TCP的长连接与短链接

  取决于怎么使用，短连接为建立连接-传输数据-断开连接，然后再建立连接-传输数据-断开连接的模式。长连接为建立连接-传输数据-保持连接-传输数据-断开连接。

  长连接是通过Keep-Alive机制实现的，在一定时间内（一般时间为 7200s）在链路上没有数据传送的情况下，**服务端**将发送相应的KeepAlive探针以确定连接存活，探测失败后重试10次，每次间隔时间75s，所有探测失败后，才认为当前连接已经不可用。但这个是在传输层上的连接存活，不能保证应用层面的连接可用性。

  - **TCP KeepAlive处于传输层，由操作系统负责，能够判断进程存在，网络通畅，但无法判断进程阻塞或死锁等问题。**

  HTTP的Keep-Alive意在连接复用，而TCP的Keep-Alive意在探测连接存活。

  服务端缓解长连接压力：服务端可以清理那些长时间没有通信的连接，或者限制客户端的最大空闲连接时长。

- 应用层心跳：**客户端**会开启一个定时任务，定时对已经建立连接的对端应用发送心跳请求，服务端则需要特殊处理该请求，返回响应。如果心跳持续多次没有收到响应，客户端会认为连接不可用，主动断开连接。

  - 优化：利用正常的请求来作为心跳。

##### IP/ICMP/路由

- IP地址

  <img src="img/IP地址分类.png" style="zoom: 33%;" />

- ICMP（Internet Control Message Protocol）用于确认网络是否正常、遇到异常时的问题诊断。

- 路由器根据路由控制表转发IP数据包，它根据收到的数据包中目标主机的IP地址，在路由控制表中查找得到下一个应该接收的路由器。

##### HTTP

- 请求报文由请求行（请求方法、请求 URI、协议版本）、请求首部字段、空文本行和请求体构成。

  响应报文由响应行（协议版本、状态码、用以解释状态码的原因短语）、响应首部字段、空文本行和响应体构成。

- HTTP的通信过程：建⽴TCP连接->发送请求⾏->发送请求头->（到达服务器）发送响应⾏->发送响应头->发送响应数据->断开TCP连接。

- HTTP1.0和1.1的区别：

  - 支持的方法有区别，如OPTIONS只有1.1支持。
  - 首部字段有区别。
  - 1.1支持持久连接、管线化（连续发送请求）。

- HTTP和HTTPS的区别：

  - HTTP不需要加密、认证，因此不太安全，但是速度快。HTTPS需要加密、认证，更加安全，但是更慢。
  - HTTP端口号80。HTTPS端口号443。
  - HTTP是单纯的应用层协议，HTTPS涉及SSL协议，它是传输层的协议。

- HTTPS的证书类型：单域名、多域名、通配符、DV、OV、EV。

- HTTPS的工作过程：建立连接时，服务器向客户端发送自己的CA证书，客户端根据证书对服务端进行认证，然后用证书中的公钥对接下来要使用的共享密钥进行加密，发送给服务端。服务端使用自己的私钥解密，接下来的通信过程使用共享密钥进行通信。

- GET和POST方法的区别：

  - 都可以用于请求。

  - GET方法的请求参数在URI中，长度有限，相对不安全。POST方法的请求参数在请求体中，长度没有限制，相对安全。

  - GET方法单纯为了获取资源。POST方法可以向服务器传递更多信息，更改资源，例如通过表单进行注册。

- 状态码

  - 100 continue

    101 switching protocols

  - 200 ok

    204 no content

    206 partial content 范围请求成功

  - 301 moved permanently 永久性重定向

    302 found 临时性重定向

    307 temporary redirect 临时性重定向 不会把post变为get

  - 400 bad request 请求报文有语法错误

    401 unauthorized 认证失败

    403 forbidden 禁止访问

    404 not found 资源未找到

  - 500 internal server error

    503 service unavailable 服务不可用（忙或者维护）

- 首部

  - 通用首部：cache-control、date、upgrade、via
  - 请求首部：accept、host、user-agent
  - 响应首部：content-type、location、server
  
- XSS（跨站脚本攻击）与CSRF（跨站请求伪造）如何预防：

  - XSS：使用HttpOnly的cookie。
  - CSRF：检查Referer首部。

#### MySQL

##### 架构

<img src="img/Mysql连接过程.png" style="zoom: 67%;" />

1. **连接层**：最上层是一些客户端和连接服务。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。
2. **服务层**：第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等。
3. **引擎层**：第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。
4. **存储层**：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互。

- MySQL 的查询流程：验证身份、查询缓存、缓存不存在则解析SQL，优化并执行。

##### 存储引擎

常见的存储引擎有 InnoDB、MyISAM、Memory和NDB。前两者的主要区别如下：

- InnoDB 支持事务，MyISAM 不支持。
- InnoDB 支持外键，MyISAM 不支持。
- InnoDB 是聚簇索引，MyISAM 是非聚簇索引。
- InnoDB 最小的锁粒度是行锁，MyISAM最小的锁粒度是表锁。

##### 数据类型

主要包括以下五大类：

1. 整数类型：BIT、BOOL、TINYINT、SMALLINT、MEDIUMINT、 INT、 BIGINT
2. 浮点数类型：FLOAT、DOUBLE、DECIMAL
3. 字符串类型：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB
4. 日期类型：Date、DateTime、TimeStamp、Time、Year
5. 其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等

##### 索引

索引是帮助MySQL高效获取数据的数据结构，类似字典里面的目录。

- 索引的分类：
  - 按数据结构：hash、b+树等。
  - 按物理存储：聚簇索引与非聚簇索引。聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点保存指向对应数据的指针。
  - 按逻辑：主键索引、单列索引、联合索引等。

- 使用索引的优缺点：
  - 优点是提高数据检索效率；降低数据排序成本。
  - 缺点是需要额外的空间保存；降低更新表的速度。

- 常见的索引类型有：hash表，b树、b+树。
  - hash表查找时，根据key调用hash函数计算对应的hashcode，找到对应的数据行地址，根据地址得到对应的数据。

  - B树是一种多叉搜索树，每个节点有多个子节点。每个节点保存key，key对应数据的地址以及指向下一层节点的指针。查找时从根节点出发，直到找到对应的key。

  - B+树是B树的变种，主要区别在于B+树的非叶子节点只能保存key和指向下一层节点的指针。叶子节点之间通过指针连接，构成一个有序链表。

  MySQL的索引使用B+树，不使用hash、红黑树、B树的原因是：索引文件很大，不能全部读入内存，而红黑树和B树层数较多，会涉及更多的磁盘I/O操作。而hash不支持范围查找、不支持排序等操作。

  而使用B+树的好处有：

  - 磁盘IO代价更低：非叶子节点节点没有指向数据地址的指针，因此非叶子节点节点相对B树更小，这样在磁盘的一个block上可以存储更多key的信息。
  - 查询效率更加稳定：只有叶子节点保存指向数据地址的指针，因此查询所有数据都需要从根节点到叶子节点。
  - 在范围操作上效率更高：因为只需要遍历叶子节点就相当于遍历整棵树。
  
- 联合索引的命中规则：

  1. MySQL联合索引遵循最左前缀匹配规则，即从联合索引的最左列开始向右匹配，直到遇到匹配终止条件。例如联合索引(col1, col2, col3), where条件为col1=`a` AND col2=`b`可命中该联合索引的(col1,col2)前缀部分, where条件为col2=`b` AND col3=`c`不符合最左前缀匹配，不能命中该联合索引。 
  2. 匹配终止条件为范围操作符(如>, <, between, like等)或函数等不能应用索引的情况。例如联合索引(col1, col2, col3), where条件为col1=`a` AND col2>1 AND col3=`c`, 在col2列上为范围查询，匹配即终止，只会匹配到col1，不能匹配到(col1, col2, col3). 
  3. where条件中的顺序不影响索引命中。例如联合索引(col1, col2, col3), where条件为col3=`c` AND col2=b AND col1=`a`, MySQL优化器会自行进行优化，可命中联合索引(col1, col2, col3). 

##### 事务

事务是由一组SQL语句组成的逻辑处理单元。

事务四大特性ACID：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。

- 原子性：事务是最小的操作单位，这些操作要么全部成功，要么全部失败。
- 一致性：事务操作前后，数据库的完整性约束不被破坏（unique的字段不会出现重复）。
- 隔离性：事务之间相互独立，一个事务的操作不影响另一个事务。
- 持久性：一个事务提交之后，数据库会持久化地保存数据。

事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现 。

- redo log（重做日志）实现A和D。事务开启时，事务中的操作都会先写入重做日志，提前刷新到磁盘上持久化。
- undo log（回滚日志）实现C。回滚日志记录数据在每个操作前的状态。

##### 事务隔离级别

事务隔离级别：读未提交、读已提交、可重复读、串行化。

用于解决脏读、不可重复读、幻读的问题。

- 脏读：一个事务读到另一个事务还未提交的数据。
- 不可重复读：一个事务中多次读取同一个数据，结果出现不一致。
- 幻读：一个事务使用相同的SQL两次读取，第二次读取到其他事务新插入的行。（实际情况是事务一查询一条记录不存在，接下来准备插入，此时事务二插入了一条记录，导致事务一的插入操作失败。）

##### MVCC（乐观锁思想）

数据多版本并发控制（MultiVersion Concurrency Control），不用加任何锁， 通过一定机制**生成一个数据请求时间点的一致性数据快照** （`Snapshot`)，并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。

MVCC 的实现是**通过保存数据在某个时间点的快照来实现的**。具体地，通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建版本号，一个保存行的删除版本号。

##### 锁（悲观锁思想）

- 锁类型：
  - 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
  - 页级锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。（LIMIT子句）
  - 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
- innoDB的行锁算法：
  - InnoDB中的行锁的实现依赖于索引，一旦某个加锁操作没有使用到索引，那么该锁就会退化为表锁。
  - **记录锁**：存在于包括主键索引在内的**唯一索引**中，锁定单条索引记录。
  - **间隙锁**：存在于**非唯一索引**中，锁定**开区间**范围内的一段间隔，它是基于**临键锁**实现的。
  - **临键锁**：存在于**非唯一索引**中，每个数据行上的非唯一索引列上都存在这种锁，它是一种特殊的**间隙锁**，锁定一段**左开右闭**的索引区间。
- 数据库的死锁产生同样是由于两个事务以不同的顺序锁定资源。
  - InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。

##### 主从复制

- slave 会从 master 读取 binlog 来进行数据同步。

- 三个步骤

  - master将改变记录到二进制日志（binary log）。

  - salve 将 master 的 binary log events 拷贝到它的中继日志（relay log）。
  - slave 重做中继日志中的事件，将改变应用到自己的数据库中。MySQL 复制是异步且是串行化的。


##### 分布式事务

一个事务的各种操作分布在不同的服务器上完成。产生的原因是数据量太大，需要分库分表，以及业务的SOA化。

解决方案有两阶段提交以及消息事务等。

##### SQL与HQL的区别

- SQL面向数据库查询，HQL面向对象查询。
- SQL中使用表名、字段进行查询，HQL使用类名+类对象、对象的属性进行查询。

##### SQL查询的一些细节

- 一条完整sql的执行顺序：

  `FROM/JOINS	   WHERE	GROUP BY	HAVING	 SELECT	  DISTINCT	 ORDER BY	LIMIT`。

- select * 性能：与select 所有列性能基本相同，但是如果不需要所有的列，就尽量写出具体需要查询的列。

- count(*) 和 count(1)和count(列名)区别：

  - 前两个包含所有的列，不会忽略null；第三个只包含列名对应的列，会忽略null。
  - 根据列名是否为主键，count(1)和count(列名)的执行速度有所区别。

- in和exists区别：

  - exists判断子查询是否有记录返回。

  - in判断A是否在集合B内。

    ```mysql
    SELECT * FROM A WHERE A.id IN (SELECT id FROM B);
    -- 这条语句首先将B的id都列出来，然后对A的每一个id，判断它是否在集合B以内。有点类似一个双重循环。
    SELECT * FROM A WHERE EXISTS (SELECT * from B WHERE B.id = A.id);
    -- 这条语句对A的每一个id，直接在B中进行条件查询，有记录返回，就把这个id对应的记录列出来。否则看下一个id，这样就是一个一重循环，查询的过程是很快的。
    ```

- union和union all的区别：
  - 都是将两个结果集合并为一个。
  - union会筛选到重复的记录，而union all不会。
  - union会对结果集进行排序（按select关键字后的第一个字段），而union all不会。

- where和having的区别：

  - where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来。
  - where 后不可以跟聚合函数，having可以进行聚合函数的判断。

- 内连接、外连接、交叉连接（笛卡尔积）：

  <img src="img/MysqlJoins.png" style="zoom: 33%;" />

  - 内连接：取得两张表中满足存在连接匹配关系的记录。

  - 外连接：取得两张表中满足存在连接匹配关系的记录，以及某张表（或两张表）中不满足匹配关系的记录。

  - 交叉连接：显示两张表所有记录一一对应的结果。

    ```
    表1 A B
    表2 C D
    交叉连接：AC AD BC BD
    ```

- 交叉连接的性能最差、内连接和外连接效率差不多，需要看具体情况。

##### SQL如何优化

- 最主要的是避免进行全表扫描。
- 在where子句涉及的列上适当地创建索引。
- 少写子查询，多用连接操作（join）。
- 避免使用select *，查询需要的字段。
- 用EXISTS替代IN。

#### Redis

Redis（REmote Dictionary Server）是一种非关系型数据库，将数据以键值对的形式保存在内存中，也可以持久化到硬盘中。主要应用在缓存（键过期）、排行榜、计数器、消息队列（发布订阅功能）、通过集合的操作（交并等）完成好友关系等。

##### 为什么快

- 所有数据存放在内存中。
- 使用C语言。
- 单线程架构。
  - 内存访问；非阻塞IO；不存在上下文切换。
- 代码牛逼。

##### 两种持久化机制：RDB 和 AOF

  - RDB：当前进程的数据生成快照存入到磁盘中。适用于全量备份。
  - AOF：把写指令都记录下来，重启redis时再执行它们恢复数据。适用于实时地持久化数据，因为只记录写指令。

##### Sentinel（哨兵）

哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。可以在master宕机时自动进行**故障切换**，将slave切换成master。

- 故障切换过程：假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为**主观下线**。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为**客观下线**。这样对于客户端而言，一切都是透明的。

##### 缓存穿透、缓存击穿、缓存雪崩三大问题

- 缓存穿透：客户持续向服务器查询不存在的key。先在Redis中查询，查询不到后去数据库中查询。
  - 如何避免：对查询结果为空的情况也进行缓存、对请求参数进行过滤。
- 缓存击穿：一个key对应的数据过期了，这时收到大量的请求，只能到数据库中查询。
  - 如何避免：设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。
- 缓存雪崩：大量缓存集中在某一个时间段失效，这时收到大量的请求，只能到数据库中查询。
  - 如何避免：不同缓存的过期时间设置随机。

##### 数据淘汰机制

为一个key设置过期时间，然后使用定期删除和惰性删除两种方式删除过期的数据。

- 定期删除：每隔一段时间随机抽取一些过期的key进行删除。
- 惰性删除：过期的key被访问时再进行删除。

##### 五种数据类型

- 字符串类型 string
  - 应用场景：缓存、计数、共享session。
- 哈希类型 hash
  - 应用场景：保存关系型表的数据。
- 列表类型 list
  - 应用场景：消息队列。
- 集合类型 set
  - 应用场景：标签、抽奖（随机选出集合中的一个或多个元素，`srandmember`）、社交。
- 有序集合类型 zset
  - 通过给每一个元素设置一个分数实现有序。

<img src="img/redis数据结构和内部编码.png" style="zoom: 50%;" />

##### 底层数据结构

- 简单动态字符串（SDS）：额外定义len属性以及free属性记录字符串的长度以及buf数组未使用的字节数量。

- 链表：双向链表。具有头、尾指针。无环。带长度计数器。

- 字典：数组+链表的形式。

- 跳跃表：一种**有序**数据结构，通过保存多层的索引，达到快速找到元素的目的。插入节点时通过概率确定它所在的最高层次，避免复杂度退化。

  ![](img/跳表.png)

- 整数集合：用于保存整数值的集合数据类型，它可以保存类型为int16_t、int32_t 或者int64_t 的整数值，并且保证集合中不会出现重复元素。

- 压缩列表：由一系列特殊编码的连续内存块组成的顺序型数据结构。前三个值记录列表长度、尾节点位置、节点个数，每个节点记录自己的类型及长度。

#### Spring Boot

- 是 Spring 开源组织下的子项目，主要简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。

- 核心注解：@SpringBootApplication，包含了@SpringBootConfiguration（实现配置文件的功能）、@EnableAutoConfiguration（开启自动配置）、@ComponentScan（组件扫描）三个注解。

- starter：提供了自动化配置类，用于自动管理依赖及版本。一般命名为 `XXXAutoConfiguration` ，在这个配置类中通过条件注解来决定一个配置是否生效，然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置。

- 自动装配：通过@EnableAutoConfiguration注解实现，它通过导入AutoConfigurationImportSelector类加载所有starter的META-INF/spring.factories文件中的配置信息，将所有符合自动装配条件（@Conditional）的bean注入到IOC容器中。

- IOC：反转控制，代码中尽量不使用new这种强引用，因为会导致比较高的代码耦合。Spring使用IOC容器（map对象）统一创建和管理对象，降低代码耦合。
  - 构造器依赖注⼊。
  - Setter方法注⼊。
  
- IOC容器的创建过程：AnnotationConfigApplicationContext的构造函数执行
  - this() 初始化bean读取器和扫描器。
  - register() 注册bean配置类，主要是处理bean的一些注解，然后将它以键值对形式保存下来。
  - refresh() 创建ioc容器，载入bean定义，完成容器初始化工作。
  
- bean的生命周期：
  - 单例对象：创建容器时被创建，销毁容器时被销毁。
  - 多例对象：使用对象时创建新的实例对象，对象消亡时被垃圾回收器回收。
  
- 实例化bean的三种方式：
  - 默认无参构造函数
  - 静态工厂
  - 实例工厂
  
- 单例：通过@Scope设置singleton、prototype等。

- 事务传播行为：当事务方法A被另一个事务方法B调用时，事务方法A应该如何进行。

  - 七种事务传播类型：

    | 事务行为                  | 说明                                                         |
    | ------------------------- | ------------------------------------------------------------ |
    | PROPAGATION_REQUIRED      | 支持当前事务，假设当前没有事务。就新建一个事务               |
    | PROPAGATION_SUPPORTS      | 支持当前事务，假设当前没有事务，就以非事务方式运行           |
    | PROPAGATION_MANDATORY     | 支持当前事务，假设当前没有事务，就抛出异常                   |
    | PROPAGATION_REQUIRES_NEW  | 新建事务，假设当前存在事务。把当前事务挂起                   |
    | PROPAGATION_NOT_SUPPORTED | 以非事务方式运行操作。假设当前存在事务，就把当前事务挂起     |
    | PROPAGATION_NEVER         | 以非事务方式运行，假设当前存在事务，则抛出异常               |
    | PROPAGATION_NESTED        | 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 |

  - 通过注解`@Transactional(propagation = Propagation.REQUIRED)`指定传播类型。

- AOP：面向切面编程，将业务逻辑的不同部分隔离，或者将重复代码抽取出来，通过动态代理的方式在运行期将它们结合起来。这样可以减少重复代码、降低耦合度，便于扩展和维护。
  
  - JDK动态代理：被代理对象需要有接口。
  - CGLib动态代理：被代理对象没有接口。
  
- @ResponseBody：响应 json  数据。
  该注解用于将 Controller 的方法返回的对象，通过 HttpMessageConverter 接口转换为指定格式的
  数据如：json，xml 等，通过 Response 响应给客户端。

#### 设计模式

##### 代理模式

给某一个对象提供一个代理，并由代理对象控制对原对象的访问引用。

##### 装饰器模式

用synchronizedList方法将ArrayList封装为同步对象。

##### 工厂模式

#### 常用公式

##### 欧几里得算法求最大公约数

- `gcd(a,b) = gcd(b,a mod b)`

  ```java
  private static int gcd(int a, int b) {
      if(b == 0) return a;
      return gcd(b, a % b);
  }
  ```

##### 牛顿迭代法求平方根

- $$x_{n+1}=\frac{1}{2}(x_n+\frac{c}{x_n})$$

  			```java
     private static double sqrt(double c) {
         if (c < 0) return Double.NaN;
         double eps = 1e-15;
         double t = c;
         while (Math.abs(t - c / t) > eps) {
             t = 0.5 * (t + c / t);
         }
         return t;
     }
  ```

##### 二分法求平方根

```java
private static double sqrtBin(double c) {
    if (c < 0) return Double.NaN;
    double left, right;
    if (c >= 1) {
        left = 0;
        right = c;
    } else {
        left = c;
        right = 1;
    }
    double mid = left + (right - left) / 2;
    while (Math.abs(mid * mid - c) > 1e-10) {
        if (mid * mid < c) left = mid;
        else right = mid;
        mid = left + (right - left) / 2;
    }
    return mid;
}
```

##### 判断素数

- ```java
  private static boolean isPrime(int n) {
      if (n < 2) return false;
      for (int i = 2; i * i <= n; i++)
          if (n % i == 0) return false;
      return true;
  }
  ```

- 计算[2，n)的素数个数

  ```java
  int countPrimes(int n) {
      boolean[] isPrim = new boolean[n];
      Arrays.fill(isPrim, true);
      for (int i = 2; i * i < n; i++)
      	if (isPrim[i])
      		for (int j = i * i; j < n; j += i)
      			isPrim[j] = false;
      int count = 0;
      for (int i = 2; i < n; i++)
      	if (isPrim[i]) count++;
      return count;
  }
  ```

##### 快速求幂算法

- 公式：$$a^b=a*a^{b-1},b为奇数；a^b=(a^{b/2})^2,b为偶数.$$

  ```java
  private static int pow(int a, int b) {
      if(b == 0) return 1;
      if(b == 1) return a;
  
      if(b % 2 == 1) {
          return a * pow(a, b-1);
      } else {
          int sub = pow(a, b/2);
          return sub * sub;
      }
  }
  ```

#### 常用数据结构与算法

##### 快速排序

```java
private static void Quick(int[] nums) {
    Quick(nums, 0, nums.length - 1);
}

private static void Quick(int[] nums, int left, int right) {
    if (left >= right) return;
    int j = partion(nums, left, right);
    Quick(nums, left, j - 1);
    Quick(nums, j + 1, right);
}

private static int partion(int[] nums, int left, int right) {
    int t = nums[left];
    int i = left + 1, j = right;
    while (true) {
        while (i <= right && nums[i] <= t) i++;
        while (j > left && nums[j] >= t) j--;
        if (i >= j)
            break;
        swap(nums, i, j);
    }
    swap(nums, left, j);
    return j;
}

private static void swap(int[] nums, int i, int j) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
```

##### 归并排序

```java
public void merge(int[] nums) {
    int[] copy = new int[nums.length];
    merge(nums, 0, nums.length-1, copy);
}

public void merge(int[] nums, int left, int right, int[] copy) {
    if(left >= right) return;
    int mid = left + (right - left) / 2;
    merge(nums, left, mid, copy);
    merge(nums, mid + 1, right, copy);
    if(nums[mid] > nums[mid + 1])
    	sort(nums, left, mid, right, copy);
}

public void sort(int[] nums, int left, int mid, int right, int[] copy){
    int i = left, j = mid + 1;
    for (int k = left; k <= right; k++) {
        copy[k] = nums[k];
    }

    for (int k = left; k <= right; k++)
        if (i > mid) nums[k] = copy[j++];
        else if (j > right) nums[k] = copy[i++];
        else if (copy[i] > copy[j]) nums[k] = copy[j++];
        else nums[k] = copy[i++];
}
```

##### 二分查找

```java
int binary_search(int[] nums, int target) {
    int left = 0, right = nums.length - 1; 
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1; 
        } else if(nums[mid] == target) {
            // 直接返回
            return mid;
        }
    }
    // 直接返回
    return -1;
}

int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定左侧边界
            right = mid - 1;
        }
    }
    // 最后要检查 left 越界的情况
    if (left >= nums.length || nums[left] != target)
        return -1;
    return left;
}

int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定右侧边界
            left = mid + 1;
        }
    }
    // 最后要检查 right 越界的情况
    if (right < 0 || nums[right] != target)
        return -1;
    return right;
}
```

##### KMP

```java
public class KMP {
    private String pat;
    private int[][] dfa;

    public KMP(String pat) {
        this.pat = pat;
        int M = pat.length();
        int R = 256;
        dfa = new int[R][M];
        dfa[pat.charAt(0)][0] = 1;
        for (int X = 0, j = 1; j < M; j++) {
            for (int c = 0; c < R; c++)
                dfa[c][j] = dfa[c][X];  //复制匹配失败情况下的值
            dfa[pat.charAt(j)][j] = j + 1;//设置匹配成功情况下的值
            X = dfa[pat.charAt(j)][X];  //更新重启状态
        }
    }

    public int search(String txt) { 
        int i, j, N = txt.length(), M = pat.length();
        for (i = 0, j = 0; i < N && j < M; i++)
            j = dfa[pat.charAt(i)][j];//在txt上运行dfa
        if (j == M) return i - M;
        else return N;
    }
}
```

##### LRU缓存淘汰策略

```java
package cn.dut.chapter3_1;

import java.util.HashMap;
import java.util.Map;

public class LRU {

    class Node {
        private int key, val;
        private Node prev, next;

        public Node(int key, int val) {
            this.key = key;
            this.val = val;
        }
    }

    class DoubleList {
        private int size;
        private Node first;
        private Node last;

        public void addFirst(Node x) {//添加到链表头，O1
            if (first == null) {
                first = x;
                last = x;
            } else {
                Node oldFirst = first;
                first = x;
                first.next = oldFirst;
                oldFirst.prev = first;
            }
            size++;
        }

        public void remove(Node x) {//直接指定节点删除，O1。通过map映射获得。
            if (x == null) return;
            if (x == first) {
                first = first.next;
                if (first != null) first.prev = null;
                size--;
            } else if (x == last) {
                removeLast();
            } else {
                Node prev = x.prev;
                Node next = x.next;
                prev.next = next;
                next.prev = prev;
                size--;
            }
        }

        public Node removeLast() {//删除最后一个节点，O1
            if (last == null) return null;
            else {
                Node rt = last;
                Node prev = last.prev;
                if (prev != null) prev.next = null;
                last = prev;
                size--;
                return rt;
            }
        }

        public int size() {
            return size;
        }
    }

    //假设双向链表提供addFirst(Node) remove(Node) removeLast() size()方法
    private Map<Integer, Node> map;
    private DoubleList cache;
    private int cap;

    public LRU(int cap) {
        this.cap = cap;
        map = new HashMap<>();
        cache = new DoubleList();
    }

    public int get(int key) {
        if (!map.containsKey(key))
            return -1;
        int val = map.get(key).val;
        put(key, val);
        return val;
    }

    public void put(int key, int val) {
        Node x = new Node(key, val);

        if (map.containsKey(key)) {
            cache.remove(map.get(key));
            cache.addFirst(x);
            map.put(key, x);
        } else {
            if (cap == cache.size()) {
                Node last = cache.removeLast();
                map.remove(last.key);
            }
            cache.addFirst(x);
            map.put(key, x);
        }
    }
}
```

<img src="img/数据结构/LRU.jpg" style="zoom: 33%;" />

##### 大顶堆实现的优先队列

```java
package cn.dut.test;

public class MaxPQ {

    private int[] pq;
    private int N;

    public MaxPQ(int cap) {
        pq = new int[cap + 1];
    }

    private boolean less(int i, int j) {
        return pq[i] < pq[j];
    }

    private void swap(int i, int j) {
        int t = pq[i];
        pq[j] = pq[i];
        pq[i] = t;
    }

    private void swim(int k) {
        while (k > 1 && less(k / 2, k)) {
            swap(k / 2, k);
            k /= 2;
        }
    }

    private void sink(int k) {
        while (2 * k <= N) {
            int j = 2 * k;
            if (j < N && less(j, j + 1)) j++;
            if (!less(k, j)) break;
            swap(k, j);
            k = j;
        }
    }

    private void insert(int val) {
        if (N == pq.length - 1) ;//扩容
        pq[++N] = val;
        swim(N);
    }

    private int deleteMax() {
        if (N == 0) ;//抛出异常
        int t = pq[1];
        swap(1, N);
        pq[N] = -1;
        N--;
        sink(1);
        return t;
    }
}
```

##### 跳表

```java
package cn.dut.chapter1_3;

import java.util.Arrays;
import java.util.Random;

public class SkipList {

    private static final int MAX_LEVEL = 16;//最大索引层数，算上最底层的链表
    private int levelCount = 1;//当前的层数
    private Node head = new Node();//头节点
    private Random random = new Random();

    public Node find(int value) {
        Node p = head;
        for (int i = levelCount - 1; i >= 0; i--) {
            while (p.next[i] != null && p.next[i].data < value)
                p = p.next[i];
        }
        if (p.next[0] != null && p.next[0].data == value)
            return p.next[0];
        else
            return null;
    }

    /**
     * 首先通过随机函数计算该节点出现的层级，然后找到每一层要插入位置的前一个节点，然后更新连接。
     *
     * @param value
     */
    public void insert(int value) {
        int level = randomLevel();
        Node newNode = new Node(value, level);

        Node[] update = new Node[level];
        Arrays.fill(update, head);

        Node p = head;
        for (int i = level - 1; i >= 0; i--) {
            while (p.next[i] != null && p.next[i].data < value)
                p = p.next[i];
            update[i] = p;//找到每一层要插入位置的前一个节点
        }

        for (int i = 0; i < level; i++) {
            newNode.next[i] = update[i].next[i];
            update[i].next[i] = newNode;
        }

        if (levelCount < level) levelCount = level;
    }

    /**
     * 首先找到每一层要插入位置的前一个节点，然后更新连接。
     *
     * @param value
     */
    public void delete(int value) {
        Node[] update = new Node[levelCount];
        Node p = head;
        for (int i = levelCount - 1; i >= 0; i--) {
            while (p.next[i] != null && p.next[i].data < value)
                p = p.next[i];
            update[i] = p;//找到每一层要删除位置的前一个节点
        }

        if (p.next[0] != null && p.next[0].data == value) {
            for (int i = levelCount - 1; i >= 0; i--) {
                if (update[i].next[i] != null && update[i].next[i].data == value)
                    update[i].next[i] = update[i].next[i].next[i];
            }
        }
    }

    private int randomLevel() {
        int level = 1;
        for (int i = 1; i < MAX_LEVEL; i++) {
            if (random.nextInt() % 2 == 1) level++;
        }
        return level;
    }

    private class Node {
        private int data = -1;
        private Node[] next = new Node[MAX_LEVEL];
        private int maxLevel = 0;//该节点所在的最高层数

        public Node() {
        }

        public Node(int data, int maxLevel) {
            this.data = data;
            this.maxLevel = maxLevel;
        }
    }
}
```

![](img/跳表.png)

##### 二叉搜索树

```java
package cn.dut.test;

public class BST {

    class Node {
        private Integer key;
        private Integer val;
        private Node left;
        private Node right;

        public Node(Integer key, Integer val) {
            this.key = key;
            this.val = val;
        }
    }

    private Node root;

    public Integer get(Integer key) {
        return get(key, root);
    }

    private Integer get(Integer key, Node x) {
        if (x == null) return null;
        if (key < x.key) return get(key, x.left);
        else if (key > x.key) return get(key, x.right);
        else return x.val;
    }

    public void put(Integer key, Integer val) {
        root = put(key, val, root);
    }

    private Node put(Integer key, Integer val, Node x) {
        if (x == null) return new Node(key, val);
        if (key < x.key) x.left = put(key, val, x.left);
        else if (key > x.key) x.right = put(key, val, x.right);
        else x.val = val;
        return x;
    }
}
```

##### 红黑树

定义：

- 有红色、黑色两种节点。
- 根节点为黑色。
- 叶子节点为黑色的空节点。
- 不会出现两个连续的红色节点。
- 完美黑色平衡的，即任意空链接到某个节点的路径上的黑链接数量相同。

三种操作：

- 如果右子节点是红色的，而左子节点（包括黑色的空节点）是黑色的，进行左旋转；
- 如果左子节点是红色的，且它的左子节点也是红色的，进行右旋转；
- 如果左右子节点均为红色，进行颜色转换。

<img src="img/红黑树红色节点上移.jpg" style="zoom: 50%;" />

##### 布隆过滤器

- 布隆过滤器是一种概率型的数据结构，可以高效的插入和查询，不支持删除，关键是通过位图的长度和hash函数的个数保证误判率在可接受范围内。根据查询结果确定一个key一定不存在或可能存在。

- 它由一个bit数组（位图）和多个hash函数实现。

  开始时位图上全部为0，存入一个key时，用所有的hash函数计算，将对应的位置标记为1。

  对一个key进行查询时，如果所有的位都是1，那么这个key可能存在；有一位不为1，那么这个key一定不存在。

- 应用：

  - 去重，如避免爬虫爬取相同的url，秒杀系统检查用户是否重复购买。
  - 大容量查询，如垃圾邮箱名单、网页黑名单。
  - 解决缓存穿透。

##### 正则表达式匹配例子

- ipv4地址的正则表达式写法：

  ipv4地址为X.X.X.X，X在0至255之间。因此可以划分255：

  0~99：`[1-9]?\d`

  100~199：`1\d{2}`

  200~249：`2[0-4]\d`

  250~255：`25[0-5]`

  因此最终为`^(([1-9]?\d|1\d{2}|2[0-4]\d|25[0-5])\.){3}([1-9]?\d|1\d{2}|2[0-4]\d|25[0-5])$`。

#### 实验室项目

可解释性：主要分为四部分内容。

- 一是可视化解释，就是通过可视化的方式，揭示图像中的哪些部分对于模型的预测起正向作用。
- 二是诊断，就是研究数据对于模型以及解释的影响，比如影响函数研究缺失一幅训练样本对于模型预测的影响、对抗样本对于各种可视化解释的影响。
- 三是模型特征的编码，就是通过其他的传统模型，构建本身可解释性良好的模型，去逼近深度模型。
- 四是可解释性技术的评估指标。

#### 博客项目

- 主要难点：
  - 整个网页的设计，包括每个页面的功能，实体类之间的关系。
  - 一些比较重要的功能都是用开源的库解决的，如markdown编辑器、markdown转html、页面排版、目录生成等等。
  - thymeleaf、jpa、springboot的一些使用。

- 为什么用thymeleaf模板引擎：

  - 搭配springboot开发非前后端分离的小型个人项目比较方便。
  - 不影响html的正常渲染，看静态页面比较方便。

- 为什么用spring data jpa：

  - 设计好实体类可以直接生成表。
  - 表之间的关系不复杂，对性能要求不高，简单的sql可以直接调用。

- 主要功能：

  - 前端展示：主页、博客详情页、分类、标签、归档。
  - 后台管理：管理员登录、博客写入与管理、分类管理、标签管理（增删改查）。

  <img src="img\blog\数据库结构.jpg" style="zoom: 80%;" />

- 辅助功能：

  - 异常处理：自定义404、500页面由springboot处理，自定义error页面由一个异常处理器处理。
  - 登录拦截：自定义一个过滤器，拦截直接访问管理页面的请求。
  - 日志记录：使用AOP的方式记录日志内容，如请求url、访问者ip等。
  - 访客记录：使用AOP的方式记录访问者IP、访问次数、上次访问时间。

- 遇到的问题：

  - 细节上的问题：

    - 文件编码格式错误

    - XML中节点定义错误

    - 连接Mysql6需要指定时区

    - 实体类中的字段加了验证，在controller中方法的对象必须加@Valid。

    - 更新博客时创建时间、查看数被重新设置为空。因为它们在前端页面没有隐藏域，每次更新时springmvc创建好的blog对象这些字段都是null。通过反射获取这些值为空的字段，更新时将这些空字段忽略掉。

    - 使用mvn打包时遇到错误，将pom.xml的maven编译插件设置为11即可。

    - 数据库的编码问题，连接数据库的时候指定了编码格式，但实际上编码格式不统一。

      <img src="img/blog/数据库编码问题.png" style="zoom: 60%;" />

  - 版本上的问题：

    - 配置类继承WebMvcConfigurationSupport添加一个过滤器，静态资源加载失败，因为它会屏蔽springboot的自动配置。而WebMvcConfigurerAdapter是过时的，因为WebMvcConfigurer接口新增了默认方法。
    - 后端校验的@NotBlank注解无法引入，因为springboot2.3后spring-boot-starter-web的依赖项已经去除了依赖hibernate-validator，需要手动引入。

  - 前端遇到的问题：

    - 一个单选框选择后需要一个清除按钮，但清除时不能只设置文本内容，还应该清除表单中对应域的value属性。实际操作时发现`removeAttr()`方法不起效果，只能设置为空字符串。