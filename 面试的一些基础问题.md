#### Java基础

##### ArrayList Vector 和Array异同

- ArrayList和Vector都是单列容器，底层都使用数组实现。
- ArrayList是非同步的，Vector是同步的。
- Array通过反射提供动态创建和访问数组的功能。

##### hashmap hashtable concurrenthashmap异同

- 它们都是双列容器。
- hashmap底层为数组+链表/红黑树（链表长度大于8时），可以存储null键和null值，非同步。
- hashtable底层为数组+链表，不可以存储null键和null值，同步。
- concurrenthashmap底层为分段的数组+链表实现，通过给每个段进行加锁，实现线程安全。

##### 抽象类和接口

- 抽象类主要用于捕捉子类的通用特性，是对类的抽象。
- 接口是抽象方法/功能的集合，是对行为的抽象。
- 相同之处：
  - 它们都不能被实例化、位于继承的顶端。
  - 都具有抽象方法。
- 不同之处：
  - 关键字不同。
  - 抽象类可以有构造函数，接口不能。
  - 一个类只能继承一个抽象类，但可以实现多个接口。

##### 多态

- 多态是指引用变量所指向的具体类型以及调用的方法是在运行期间才能确定的，具体体现在使用父类或接口的引用变量指向子类或实现类的实例对象。
- 可以分为编译时多态（方法重载，通过静态分派实现）和运行时多态（方法重写，通过动态分派实现）。

##### 反射

- 运行过程中动态获取类的信息，或者动态调用对象的方法。
- 应用场景：运行过程中动态加载字节码文件，动态代理。
- 获取反射的三种方法：
  - Class.forName(全限定名)。
  - 类名.class。
  - 对象的getClass()方法。

##### 深拷贝与浅拷贝

- 深拷贝是复制一个对象之后，引用类型引用的对象，复制独立的一份。
- 浅拷贝是复制一个对象之后，引用类型只复制引用，不复制引用的对象。

- Cloneable接口中的clone方法是浅拷贝。
- 如何实现深拷贝：
  - 继承Cloneable接口，重写clone方法。
  - 利用序列化。

##### 序列化与反序列化

- 序列化是将**对象**转换为字节流，而反序列化则是把对象从字节流中读取出来。
- 作用为完整地保存和传递对象。
- 如何实现：实现Serializable接口，通过ObjectInputStream和ObjectOutputStream中的方法进行序列化和反序列化。
- 序列号作为类的版本信息，在反序列化过程中用于告知接收者应该使用与序列号相同的类。
- static和transient类型的成员数据不能被序列化。因为static代表类的状态，transient代表对象的临时数据。

##### BIO、NIO、AIO

- BIO：同步阻塞式IO。线程进行IO操作时需要被挂起，等待IO操作完成。
- NIO：同步非阻塞式IO。线程进行IO操作时不需要被挂起，但通过轮询方式检查IO操作是否完成。
- AIO：异步IO。线程进行IO操作时不需要等待和轮询，IO操作完成时由内核通知。通过事件和回调机制实现。

#### Java线程与同步相关

##### 锁：互斥（阻塞）同步

- volatile：轻量级的同步机制，仅仅⽤来保证该变量对所有线程的并发可⻅性，但不保证原⼦性。可以用于禁止指令的重排序。

  因为会在赋值后多执行一条带有Lock前缀的空操作（内存屏障，意味着之前所有的操作已经执行完成），它会将当前处理器缓存行的数据写回到内存，同时使其他处理器里缓存了该内存地址的数据无效。这样就会使该数据对其他线程立即可见。

  但是写操作并不是原子性的，通常有好几条字节码指令，因此不能保证多个线程同时修改数据时的一致性。可以与原子类的CAS操作结合，实现原子性。

- synchronized：重量级锁，语言内置的互斥锁，保证可见性与原子性。

  字节码层面由monitorenter和monitorexit完成，标记为synchronized的方法会在方法表中ACC_SYNCHRONIZED字段体现，底层使用Monitor对象保存一些信息，如被哪条线程持有。

  JDK6之后有一些升级，如偏向锁、轻量级锁、锁粗化、锁消除、自适应自旋等。

- Lock：显式互斥锁，主要有ReentrantLock和ReentrantReadWriteLock。

  相比synchronized，用法更加灵活，但需要手动释放锁。提供了一些更高级的功能，比如

  - 等待的线程可以放弃等待。
  - 公平锁，先到先服务（使用队列完成）。
  - 支持条件对象。

  基本上是根据互斥量来实现的，即0表示锁空闲，其他值表示锁被占用。

  读写锁可以做到读数据时允许多个线程同时进入临界区，而写数据时，所有线程都是互斥的。

##### 死锁

资源死锁通常是一个线程需要持有两个锁才能继续执行，但它和另一个线程互相占有一个对方持有的锁，等待对方释放。主要原因是循环依赖，两个线程获取锁的顺序交错/不确定。解决方法有：

- 固定加锁的顺序。
- 开放调用，调用某个方法时不需要持有锁，而是只保护涉及操作共享变量的代码块。
- 使用具有定时功能的显式锁。

##### 原子类：非阻塞同步

- CAS：更新一个变量时，首先将拿到的内存值与期望值比较，如果相同，则将它更新为新值。如果不相同，则将期望值更新为内存值，**并自旋不停地尝试**。**它的关键其实在于CAS是CPU指令级别的原子操作，因此必然会保证一个线程执行完毕的结果先写入内存，让其他线程可见，这样与期望值的比较就能发挥作用。**
- 原子变量类包括基本数据类型、数组、引用类型、对象的属性等。带有版本信息的原子类，可以解决ABA问题。

##### ThreadLocal

ThreadLocal提供线程私有的变量，可以用于一些线程之间需要隔离的操作，如对于数据库的连接需要每个线程独占。

提供一个set方法，使用map集合将ThreadLocal对象和变量关联起来。**每个Thread对象持有一个map集合**，调用get方法时，当前线程的ThreadLocal对象作为key获取它对应的值。

##### Java线程

- 使用操作系统的原生线程1对1映射。

- 使用抢占式线程调度，有10个线程优先级。

- 定义了6种线程状态：新建、运行、阻塞、限时等待、无限期等待（类似于就绪）、结束。

  <img src="img\java虚拟机\线程状态转换.jpg" style="zoom: 33%;" />

- 创建线程的方式：继承Thread类、实现Runnable接口。

##### Java线程池

线程的集合，当请求到来时给它分配一个空闲线程，任务完成后回到线程池中而不是销毁。

为什么用它，因为为每个请求开启一个线程，一方面线程的创建和销毁开销比较大，另一方面请求过多或收到恶意攻击将导致程序崩溃。因此使用线程池可以减少对线程生命周期的管理，提高性能。另外，使用线程池还可以根据项目灵活地控制并发的数目。

- 线程池API：

  Executor接口，提供“任务提交”与“任务执行”分离的线程池机制。

  ThreadPoolExecutor类最为常用，一般使用Executors工厂方法来配置。它有两个属性，corePoolSize和maximumPoolSize：

  - 如果运行的线程数小于corePoolSize，则新创建线程来处理请求，即使其他线程是空闲的。
  - 如果运行的线程数大于corePoolSize，小于maximumPoolSize，则仅当任务队列满时才创建新线程。
  - 如果设置corePoolSize和maximumPoolSize相同， 则创建了固定大小的线程池。
  - 如果设置maximumPoolSize为一个巨大的值如Integer.MAX_VALUE，则允许线程池适应任意大小的并发任务。

  任务队列有三种排队策略：

  - 直接提交给线程（同步移交）。
  - 无界限的队列（超过核心线程数就放入队列等待）
  - 有界限的队列（需要权衡队列容量与最大线程容量）。

  拒绝任务有四种策略：

  - 直接抛出异常。
  - 用调用者所在线程来执行任务。
  - 直接丢弃该任务。
  - 丢弃最老的一个任务。

  线程池的状态有五种：RUNNING、SHUNTDOWN、STOP、TIDYING、TERMINATED。

  默认实现的池：newFixedThreadPool，一个固定线程数的线程池；newCachedThreadPool，直接提交给线程的、最大线程数为Integer.MAX_VALUE的线程池。SingleThreadExecutor，单个工作线程的线程池。

#### Java虚拟机

- 运行时数据区：方法区、堆，线程共享，栈（虚拟机栈，本地方法栈）、程序计数器，线程私有。

  - 方法区用于存放加载的类型信息、常量、静态变量等。

  - 堆用于存放对象。
  - 栈用于存放局部变量、操作数栈、方法出口等。
  - 程序计数器用于指示当前线程执行的字节码指令行号。

- new指令创建对象过程：

  1. 首先检查类型是否已被加载、解析和初始化过。
  2. 类型检查通过后，为对象分配一块内存空间。
  3. 将内存空间初始化为0，对对象头（类的信息、哈希码、GC年龄等）进行设置。
  4. 执行实例构造函数，对对象进行初始化。

- 对象的内存布局：对象头、实例数据和对齐填充。

  对象的访问方式有句柄和直接指针两种，Java为直接指针。

- 垃圾收集

  - 如何判断对象存活：引用计数法、可达性分析。
  - 垃圾收集算法：标记-清除，标记-复制，标记-整理。
  - 经典垃圾收集器：基于分代收集理论，通常为两类，一类用于收集新生代，一类用于收集老年代。

    - Serial：新生代收集器，基于标记-复制算法。单线程工作。
    - ParNew：新生代收集器，基于标记-复制算法。多线程工作。
    - Parallel Scavenge：新生代收集器，基于标记-复制算法。多线程工作。可以控制吞吐量。
    - Serial Old：老年代收集器，基于标记-整理算法。单线程工作。
    - Parallel Old：老年代收集器，基于标记-整理算法。多线程工作。可以控制吞吐量。
    - CMS：老年代收集器，基于标记-清除算法。多线程工作。可以并发标记和清除，低停顿。
    - Garbage First：混合收集器，基于标记-复制算法。基于Region的堆内存设计，根据Region的价值进行回收。
  - 过程：当一个对象已经不存在指向它的引用时，它成为可回收的对象。虚拟机会额外启动一条垃圾收集线程对这些可回收对象进行回收，总体过程就是先通过可达性分析进行标记，然后回收。

- class文件采用无符号数和表两种数据类型存储数据。结构为魔数、虚拟机版本、常量池表、访问标志、继承关系、字段表、方法表、属性表。

- 类加载机制：虚拟机把描述类的class文件加载到内存，对数据进行校验、转换解析和初始化的过程。

  类加载的过程为加载、连接（验证、准备、解析）、初始化、使用和卸载。

  - 加载：通过类的全限定名获取class文件，将它转化为方法区的运行时数据结构，在堆中生成一个对应的Class对象。
  - 验证：class文件格式校验、类的元数据验证、方法体的字节码验证、符号引用验证。
  - 准备：为类中定义的静态变量分配内存并设置初始值，初始化虚方法表。
  - 解析：将常量池内的符号引用替换为直接引用。
  - 初始化：执行类构造器方法，根据代码的内容初始化静态变量。

- 类加载器：在虚拟机外部实现，通过一个类的全限定名获取它的class文件。不同的类加载器加载的同一个class文件也不是一个类。

- 类加载架构：三层类加载器，双亲委派模型。

  启动类加载器，扩展类加载器（平台类加载器，JDK9），应用程序类加载器。它们管理的范围不同，确保程序运行的稳定性，如java.lang.Object类只会由启动类加载器加载，所有的java.lang.Object类都是同一个。

  工作机制：一个类加载器收到的类加载请求后，首先把它委派给父类加载器去完成，每一层都是如此。只有当父类加载器无法完成加载请求时，子类加载器才会尝试完成。

- 方法调用：解析调用和分派调用两种。

  - 解析调用：静态方法、私有方法、实例构造器等非虚方法，在解析阶段就能确定方法的版本。
  - 分派调用：静态分派（重载，编译时根据传递的参数确定方法版本）、动态分派（重写，运行时根据实际对象确定方法版本）。

- Java内存模型：

  - Java内存模型将内存分为了**主内存和工作内存**。所有的变量都存储在主内存中，每条线程拥有自己的工作内存，其中保存被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存完成。
  - 定义了几个原子操作，用于完成主内存与工作内存之间的交互。
  - 定义了volatile变量的使用规则。
  - 先行发生原则。
  
- 编译与翻译：编译是直接把代码转换为机器码，而翻译是将代码转换为另一种中间代码，

#### 操作系统

##### 进程、线程之间的区别与通信方式

- 进程是一个正在运行的程序的实例，它是系统分配资源和调度的独立单位。它包含程序运行的所有资源，如程序正文、打开的文件、程序计数器等。

  线程是进程的执行单元，每个进程至少有一条线程。线程是对CPU的抽象，它包含程序计数器、寄存器、堆栈等。

- 进程之间的通信方式有（用于进程之间的数据交互或同步）
  - 管道（pipeline）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。
  - 信号量：用一个整型变量记录可以进入临界区的最大进程数。
  - 信号：用于通知接收进程某个事件已经发生。
  - 消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。
  - 管程：一种高级同步原语，它是语言层面上提供的同步。任一时刻管程中只能有一个活跃进程。
  - 共享内存。
  - 套接字（socket）：通常用于不同机器的进程之间通信，如互联网。
- 线程之间的通信方式有（用于线程之间同步）
  - 锁机制：各种互斥锁、条件变量。
  - 信号量：用一个整型变量记录可以进入临界区的最大线程数。两种原子操作down和up，类似于sleep和wakeup。当一个线程进入临界区时，使用down检查信号量是否大于0，若大于0，则将其值减1，若为0，则线程将睡眠。当一个线程离开临界区时，使用up将信号量的值加1，如果该信号量有睡眠线程，则值仍然为0，但唤醒该线程。
  - 信号。

##### 同步IO/异步IO

同步IO中，用户进程发起IO操作后需要等待（阻塞）或轮询（非阻塞）IO操作是否就绪，然后将数据从内核态拷贝到用户态，这个过程也需要阻塞。

异步IO中，用户进程发起IO操作后返回，继续运行。IO操作完成时得到通知，数据从内核态拷贝到用户态的过程由内核完成，因此全程不需要阻塞。

<img src="img/IO.png" style="zoom: 67%;" />

- 同步IO的特点：
  - 同步IO指的是用户进程触发I/O操作并等待或者轮询的去查看I/O操作是否就绪。
  - 同步IO的执行者是IO操作的发起者。
  - 同步IO需要发起者进行内核态到用户态的数据拷贝过程，所以这里必须阻塞。

- 异步IO的特点：
  - 异步IO是指用户进程触发I/O操作以后就立即返回，继续开始做自己的事情，而当I/O操作已经完成的时候会得到I/O完成的通知。
  - 异步IO的执行者是内核线程，内核线程将数据从内核态拷贝到用户态，所以这里没有阻塞。

#### MySQL

- 事务隔离级别：读未提交、读已提交、可重复读、串行化。

  用于解决脏读、不可重复读、幻读的问题。

  脏读：一个事务读到另一个事务还未提交的数据。

  不可重复读：一个事务中多次读取同一个数据，结果出现不一致。

  幻读：一个事务使用相同的SQL两次读取，第二次读取到其他事务新插入的行。

- 事务四大特性ACID：原子性（Atomicity）、持久性（Consistency）、隔离性（Isolation）、一致性（Durability）。

  原子性：事务是最小的操作单位，这些操作要么全部成功，要么全部失败。

  隔离性：事务之间相互独立，一个事务的操作不影响另一个事务。

  持久性：一个事务提交之后，数据库会持久化地保存数据。

  一致性：事务操作前后数据的总量不发生变化。

- 索引：索引是帮助MySQL高效获取数据的数据结构，类似字典里面的目录。

  常见的索引类型有：hash表，b树、b+树。

  hash表查找时，根据key调用hash函数计算对应的hashcode，找到对应的数据行地址，根据地址得到对应的数据。

  B树是一种多叉搜索树，每个节点有多个子节点。每个节点保存key，key对应数据的地址以及指向下一层节点的指针。查找时从根节点出发，直到找到对应的key。

  B+树是B树的变种，主要区别在于B+树的非叶子节点只能保存key和指向下一层节点的指针。叶子节点之间通过指针连接，构成一个有序链表。

- MySQL的索引使用B+树，不使用hash、红黑树、B树的原因是：当数据量较大时无法全部读入内存，红黑树和B树层数较多，会涉及更多的I/O（内存页置换）操作。而hash不支持范围查找、不支持排序等操作。

#### Spring Boot

- 是 Spring 开源组织下的子项目，主要简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。
- 核心注解：@SpringBootApplication，包含了@SpringBootConfiguration（实现配置文件的功能）、@EnableAutoConfiguration（开启自动配置）、@ComponentScan（组件扫描）三个注解。
- starter：提供了一个自动化配置类，一般命名为 `XXXAutoConfiguration` ，在这个配置类中通过条件注解来决定一个配置是否生效，然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置。
- IOC：反转控制，代码中尽量不使用new这种强引用，因为会导致比较高的代码耦合。Spring使用IOC容器（map对象）统一创建和管理对象，降低代码耦合。
- 单例：通过@Scope设置singleton、prototype等。
- AOP：面向切面编程，将业务逻辑的不同部分隔离，或者将重复代码抽取出来，通过动态代理的方式在运行期将它们结合起来。这样可以减少重复代码、降低耦合度，便于扩展和维护。

#### 计算机网络

##### MAC地址

- 长48位，由厂商识别码和厂商内识别码来保证不重复。

##### NAT

- NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时使用全局IP的技术。当私有网络内的多台机器同时与外部进行通信时，将端口号一起转换（NAPT）。

##### 五层/七层网络体系

- 应用层：HTTP、SMTP、FTP、DNS、SSH、DHCP
- 传输层：TCP、UDP
- 网络层：IP、ARP、ICMP、各种路由协议（RIP、OSPF、BGP）
- 数据链路层：以太网、PPP、各种WLAN协议（IEEE802.11、蓝牙）
- 物理层

  与OSI七层网络体系的区别在于表示层和会话层被取消，作用融入到应用层和传输层中。

##### TCP/UDP

- UDP（user data protocol）提供面向无连接的通信，可以随时发送数据，不需要接收端进行确认。

  不提供流量控制、丢包重发等等复杂的控制功能，因此不能保证可靠传输。

  不提供拥塞控制，网络出现拥塞后不会使发送端降低速率。

  面向报文，一次传输交付一个完整报文，因此传输时不合并、拆分，不存在粘包问题。

  支持一对一、一对多、多对一和多对多的通信。

- TCP（transmission control protocol）提供面向有连接的通信，而且是全双工通信。

  提供了数据传输时充分的控制功能，以实现可靠性传输。

  面向字节流，传输时拆分为数据段，因此可能出现粘包问题。

  提供一对一的通信。

- 三次握手：假设B处于监听状态，A首先向B发送一个请求报文，SYN=1。然后B向A发送一个回复报文，SYN=1，ACK=1。最后A再进行确认，向B发送一个回复报文，ACK=1。这个过程种虽然没有实际数据，但需要双方确定序列号。

  为什么三次：一个角度是避免失效的连接请求发送到服务端，服务端直接建立连接浪费资源。另一个角度是确认双方的收发功能都没有问题。

- 四次挥手：A要断开连接，向B发送一个请求报文，FIN=1。然后B向A发送一个回复报文，ACK=1，表明B知道要断开连接了，此时处于半断开状态（A已经不会再给B发送数据）。然后B可能还有数据要发送，因此等剩余数据发送完毕后，向A发送一个回复报文，FIN=1。然后A再进行确认，向B发送一个回复报文，ACK=1，接着等待一段时间（2MSL），确保最后这个报文到达了B，以及本次连接产生的所有报文都从网络中消失。

- 重发控制（ARQ，停止等待协议）：发送端发包后计算往返时间，将往返时间和偏差相加作为重发时间间隔。再次发送时，以2、4的指数增长。

- 滑动窗口/流量控制（连续ARQ）：发送端控制一个滑动窗口，滑动窗口内的数据不需要进行确认即可直接发送，接收端通常采用累积确认的方式，对按序到达的最后一个包进行确认。不考虑阻塞的情况下，窗口大小由接收端的缓存大小所确认的，确保接收端来得及接收数据。

- 拥塞控制（慢启动、拥塞避免、快重传、快恢复）：发送端控制一个拥塞窗口，通信开始时为了避免发送一个大数据导致网络瘫痪，使用慢启动算法，即拥塞窗口设置为一个报文段，每收到一个ACK，拥塞窗口增加一个报文段。当拥塞窗口超过慢启动阈值后，拥塞窗口呈线性增长，即拥塞避免算法。

  当出现超时重发时，慢启动阈值设置为当前窗口的一半，并将拥塞窗口回归1个报文段。

  当出现重复确认应答时，即快重传算法，慢启动阈值设置为当前窗口的一半，并将拥塞窗口设置为慢启动阈值，即快恢复算法。

  ![](img/TCPIP/65.png)

- 提高网络利用率的规范

  - Nagle算法：仅当满足已发送的数据都已经收到ACK，或可以发送MSS长度的数据时进行发送数据，否则就延迟发送数据。
  - 延迟确认应答：接收端收到数据后不马上发送ACK，避免每次接收到数据后由于缓冲区的占用发送小的窗口大小。
  - 捎带应答：确认应答和回执数据通过一个包发送。例如三次握手中服务器给客户都发送ACK和SYN在一个包中。

##### 路由

- 路由器根据路由控制表转发IP数据包，它根据收到的数据包中目标主机的IP地址，在路由控制表中查找得到下一个应该接收的路由器。

##### HTTP

- 请求报文由请求行（请求方法、请求 URI、协议版本）、请求首部字段、空文本行和请求体构成。

  响应报文由响应行（协议版本、状态码、用以解释状态码的原因短语）、响应首部字段、空文本行和响应体构成。

- HTTP的通信过程：建⽴TCP连接->发送请求⾏->发送请求头->（到达服务器）发送响应⾏->发送响应头->发送响应数据->断TCP连接。

- HTTP1.0和1.1的区别：

  - 支持的方法有区别，如OPTIONS只有1.1支持。
  - 首部字段有区别。
  - 1.1支持持久连接、管线化（连续发送请求）。

- HTTP和HTTPS的区别：

  - HTTP不需要加密、认证，因此不太安全，但是速度快。HTTPS需要加密、认证，更加安全，但是更慢。
  - HTTP端口号80。HTTPS端口号443。
  - HTTP是单纯的应用层协议，HTTPS涉及SSL协议，它是传输层的协议。

- HTTPS的工作过程：建立连接时，服务器向客户端发送自己的CA证书，客户端根据证书对服务端进行认证，然后用证书中的公钥对接下来要使用的共享密钥进行加密，发送给服务端。服务端使用自己的私钥解密，接下来的通信过程使用共享密钥进行通信。

- GET和POST方法的区别：

  - 都可以用于请求。

  - GET方法的请求参数在URI中，长度有限，相对不安全。POST方法的请求参数在请求体中，长度没有限制，相对安全。

  - GET方法单纯为了获取资源。POST方法可以向服务器传递更多信息，更改资源，例如通过表单进行注册。

- 状态码

  - 100 continue

    101 switching protocols

  - 200 ok

    204 no content

    206 partial content 范围请求成功

  - 301 moved permanently 永久性重定向

    302 found 临时性重定向

    307 temporary redirect 临时性重定向 不会把post变为get

  - 400 bad request 请求报文有语法错误

    401 unauthorized 认证失败

    403 forbidden 禁止访问

    404 not found 资源未找到

  - 500 internal server error

  - 503 service unavailable 服务不可用（忙或者维护）

- 首部
  - 通用首部：cache-control、date、upgrade、via
  - 请求首部：accept、host、user-agent
  - 响应首部：content-type、location、server





